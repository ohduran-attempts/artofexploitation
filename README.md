initialised# Art of Exploitation

In order to hack away in a tested environment, do the following:

1. Install [Docker](https://itnext.io/docker-101-fundamentals-the-dockerfile-b33b59d0f14b)
2. ```docker build -t exploitation:latest .```
3. ```docker run -it --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -v $PWD:/app exploitation:latest bash```
4. Inside GDB, do ```set disassembly-flavor intel```.

## Main TakeAways

- Hackers get their edge from knowing how all the pieces interact within the bigger picture.

- Thinking of C-source as a program is a common misconception that is exploited by hackers every day. As long as the compiled program works, the average programmer is only concerned with source code. But a hacker realizes that the compiled program is what actually gets executed out in the real world.

- Most hacker exploits are a lot like magic tricks—they seem amazing and magical, unless you know about sleight of hand and misdirection.

- The important thing to remember about variables in C is that the compiler is the only thing that cares about a variable’s type.

## Programming

### firstprog.c & firstprog.txt

The hexadecimal numbers— 100000f40— are memory addresses. Like a row of houses on a local street, memory can be thought of as a row of bytes, each with its own memory address.

The hexadecimal bytes in the middle are the machine language instructions for the processor. The machine code is displayed as bytes and each instruction is put on its own line, like splitting a paragraph into sentences.

The instructions on the far right are in assembly language; a collection of mnemonics for the corresponding machine language instructions. Assembly language instructions have a direct one-to-one relationship with their corresponding machine language instruction; each processor has a different form of assembly language. While you can theoretically create your own x86 assembly language syntax, most people stick with one of the two main types: AT&T syntax and Intel syntax. It’s easy to recognize AT&T syntax by the cacophony of % and $ symbols prefixing everything.

### GDB
Inside Docker: ```docker run -it  --rm -v $(pwd):/app ubuntu:latest bash``` (remember to do apt-get build-essentials gdb to have gdb and gcc)

```gdb -q ./a.out```

#### General purpose registers:

- rax: Accumulator
- rbx: Base
- rcx: Counter
- rdx: Data

Temporary variables for the CPU

#### Pointers and indexes

- rsi: Source Index
- rdi: Destination Index
- rbi: Base Pointer
- rsi: Stack Pointer

Pointers store memory addresses; Indexes point to source and destination where data needs to be read from or written to.

### Instruction Pointer

- rip: Instruction Pointer

Like a child pointing his finger at each word as he reads, the processor reads each instruction using the RIP register as finger.

At first, it points at 0x5648307eb63e. Check out firstprog-Intel-ubuntu: the first memory address is 63a!

Now, what is 63b and 63e doing:

63b:	48 89 e5             	mov    rbp,rsp
63e:	48 83 ec 10          	sub    rsp,0x10

The assembly instructions in Intel syntax generally follow this style: operation <destination>, <source>. Mov will move a value from the source to destination, sub will subtract, inc will increment, etc.

- gdb break main ... run ... info registers rip

First, the breakpoint is set at the start of main(), and the program is run. Since the breakpoint has been set at the start of main, the program hits the breakpoint and pauses before actually executing any instructions in main.

notice that ```info register rip``` points to an instruction in the main() function's disassembly (the fourth, to be precise). The instruction before this are collectively known as the *function prologue* and aer generated to set up memory for the rest of the main function local variables. In fact, we declare. variables in C in order to aid the construction of this prologue.

The debugger knows this, and skips over this part.

- Examine memory using ```x```

The default size of a single unit is a four byte unit called a *word*. This is confusing because sometimes it also refers to a 2 byte value, and thus a DWORD, or double word refers to a 4-byte value. We'll use word and DWORD interchangeably.

b - single byte
h - halfword, two bytes
w - word, four bytes
g - giant, eight bytes

And the format:

o - octal
x - hexadecimal
u - unsigned, standard decimal
t - binary

A number can also be prepended to the format of the examine command to examine multiple units at the target address.

You can try ```x/8xb $rip```. This is what you may get:

(gdb) x/8xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00	0xeb

(gdb) x/8xh $rip

0x563dfc6f1642 <main+8>:	0x45c7	0x00fc	0x0000	0xeb00	0x4810	0x3d8d	0x00a2	0x0000

(gdb) x/8xw $rip

0x563dfc6f1642 <main+8>:	0x00fc45c7	0xeb000000	0x3d8d4810	0x000000a2

0x563dfc6f1652 <main+24>:	0xfffeb9e8	0xfc4583ff	0xfc7d8301	0xb8ea7e09


Now, you may have noticed that those commands that use bigger units display more data. However, x/8xb showed the first two bytes to be 0xc7 and 0x45, __but__ x/8xh showed that memory address to be 0x45c7, and x/8xw also shows 0x00fc45c7, which keeps reversing the two memory addresses showed in x/8xh.

In the x86 processor, values are stored in *little-endian* byte order, which means that the least significant byte is stored first. GDB is simply smart enough to know how values are stored, so when a word or halfword is examined, the bytes must be reversed.

Revisiting these values displayed both as hexadecimal and unsigned decimals might help clear up any confusion.

(gdb) x/4xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00

(gdb) x/4ub $rip

0x563dfc6f1642 <main+8>:	199	69	252	0

(gdb) x/1uw $rip

0x563dfc6f1642 <main+8>:	16532935

Notice this: 199 * (256^3) + 69 * (256^2) + 252 * (256^1) + 0 = 3343252480 WRONG!

But: 0 * (256^3) + 252 * (256^2) + 69 * (256^1) + 199 = 16532935 RIGHT!


GDB can also disassemble machine language into assembly instructions, with the command ```i```:

(gdb) x/i $rip

=> 0x563dfc6f1642 <main+8>:	movl   $0x0,-0x4(%rbp)

(gdb) x/3i $rip

=> 0x563dfc6f1642 <main+8>:	movl   $0x0,-0x4(%rbp)
   0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>
   0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4

Since the RIP register points to memory that contains machine language instructions, they disassemble nicely, and matches what we did with ```objdump``` (check out lines 4 to 6 in firstprog-ATT-ubuntu).

The first instruction will move the value of 0x0 (0, obviously) into memory located at the address stored in the RBP register, minus 0x4 (4, ditto). That's where the C variable ```i``` is stored! And the 4 is exactly the size of an integer on the x86 processor! It follows that this command will zero out the variable i for the for loop.

The memory at this location can be examined in several ways:

(gdb) i r $rbp

rbp            0x7ffe3e65d3d0	0x7ffe3e65d3d0

(gdb) x/4xb $rbp - 4

0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(gdb) x/4xb $rbp - 4
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

Oh, wow. The book was expecting random garbage, but I can see that the variable is initialised as 0. Looking at this [question from SO](https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value), it doesn't make any sense.

Ah, wait. I did initialised the variable, ```for (i=0....)```! My Mac is probably misbehaving, or I'm using a version of C that outdated this book.

Now, if $rbp ends in d0, then 4 bytes before in terms of address is cc (-1byte is cf, -2 is ce, -3 is cd, then -4 is cc). So the address showed is correct and in fact:

(gdb) x/4b 0x7ffe3e65d3cc
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(gdb) print $rbp -4
$1 = (void *) 0x7ffe3e65d3cc


(gdb) x/4b $1
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

print also allows us to both print a particular value in a certain address and store that address on a variable.


---

Let's execute the current instruction using the command ```nexti```. The processor will read RIP, execute it, and advance RIP to the next instruction address.

(gdb) nexti
0x0000563dfc6f1649	6	    for(i=0; i < 10; i++){

(gdb) x/4xb $1
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(Now it displays 0, again!)

(gdb) i r $rip
rip            0x563dfc6f1649	0x563dfc6f1649 <main+15>

(gdb) x/i $rip
=> 0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>

i = 0, and RIP goes to the next instruction:

(gdb) x/10i $rip
=> 0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>
   0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4
   0x563dfc6f1652 <main+24>:	callq  0x563dfc6f1510 <puts@plt>
   0x563dfc6f1657 <main+29>:	addl   $0x1,-0x4(%rbp)
   0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)
   0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>
   0x563dfc6f1661 <main+39>:	mov    $0x0,%eax
   0x563dfc6f1666 <main+44>:	leaveq
   0x563dfc6f1667 <main+45>:	retq   
   0x563dfc6f1668:	nopl   0x0(%rax,%rax,1)

First, jump to 65b. That's easy: it's the instruction below, the one that says ```cmp```. It's a compare instruction, number 0x9 with what's stored in $rbp - 0x04.
The next is ```jle```, jump if less or equal, which combined with the previous means that if variable i is less or equal than 9, then jump tp 64b. Since we know that i is now 0, we are going to be directed to that 64b. At least for now.

(gdb) nexti

0x0000563dfc6f165b	6	    for(i=0; i < 10; i++){

(gdb) x/i $rip

=> 0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)

(gdb) x/i $rip

=> 0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>

Now, next instruction:

(gdb) nexti

7	        puts("Hello, world\n");

(gdb) i r $rip

rip            0x563dfc6f164b	0x563dfc6f164b <main+17>

(gdb) x/2i $rip
=> 0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4

   0x563dfc6f1652 <main+24>:	callq  0x563dfc6f1510 <puts@plt>

So yes, 64b, and the instruction ```lea```. That's Load Effective Address, which means that the value in RIP + 0xa2 is moved onto $RDI. It's like a mov, but with memory addresses (the old book keeps the mov, it's perhaps the version of the compiler.

But what's so special about storing $RIP + 0xa2 into $RDI?? What is RDI pointing at?

(gdb) x/6xb $rdi

0x563dfc6f16f4:	0x48	0x65	0x6c	0x6c	0x6f	0x2c

(gdb) x/6cb $rdi

0x563dfc6f16f4:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	44 ','

(gdb) x/s $rdi

0x563dfc6f16f4:	"Hello, world\n"

Neat! It stores the string "Hello world"!

Remember, in the AoE book:

- ESP = RDI

- EIP = RIP

So if I do ```n``` (for next):

(gdb) n  
Hello, world

6	    for(i=0; i < 10; i++){

Bum! It prints the string!

What are the next three instructions?

(gdb) x/2i $rip
=> 0x563dfc6f1657 <main+29>:	addl   $0x1,-0x4(%rbp)

   0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)

   0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>

One means add 1 into what's stored in $RBP -4 (variable i, remember?). The second one compares, once again, the variable i and 9. And the third acts upon that comparison: again, if i is less than or equal to 9, go to 64b, and start again. That's the for loop, in action.

That's "hello, world." -- drop mic.

### Back to basics

#### Strings

Did you noticed? $rdi, in line 7, points to 0x563dfc6f16f4, which stored the value 0x48. That's when we did ```x/6cb``` and realised that the next 6 bytes referred to H, e, l, l, o, and so on. The variable wasn't a string: it was a pointer to the first letter. When calling callq on [puts](http://www.cplusplus.com/reference/cstdio/puts/), "The function begins copying from the address specified (str) until it reaches the terminating null character ('\0'). This terminating null-character is not copied to the stream."

I'm not in a position to actually look inside but we're close enough to the machine already.

In order to see it, we'll run char_array.c with the debugger:


```
#include <stdio.h>
int main()
{
char str_a[20];
 str_a[0] = 'H';
 str_a[1] = 'e';
 str_a[2] = 'l';
 str_a[3] = 'l';
 str_a[4] = 'o';
 str_a[5] = ',';
 str_a[6] = ' ';
 str_a[7] = 'w';
 str_a[8] = 'o';
 str_a[9] = 'r';
 str_a[10] = 'l';
 str_a[11] = 'd';
 str_a[12] = '!';
 str_a[13] = '\n';
 str_a[14] = 0;
 printf(str_a);
}
```


The first thing to be noticed is the warning when compiling it:

warning: format string
      is not a string literal (potentially
      insecure) [-Wformat-security]

The debugger is noticing something weird: it's not a string, but a list. However, it's not stopping the compiler from doing its job, so let's push it.


When I do ```./char_array```, the console prints "Hello, world", as expected. Which means that a string isn't really a string, but a list of char, and the reference is the pointer to the first char, with '/0' being the end of the string. That's the delimiter character.

- The number begins at 0.
- The last character is a /0, __null-byte__.
- The character array was defined, so 20 bytes are allocated for it, but only 12 of these bytes are actually used.

Since setting each character in a character array is painstacking and strings are used often, a set of standard functions was created for string manipulation: ```strcpy()``` will copy a string from a source to a destination. We can rewrite char_array.c using this function:

###### char_array2

```c
#include <stdio.h> #include <string.h>
int main() {
char str_a[20];
strcpy(str_a, "Hello, world!\n");
printf(str_a); }
```

#### Signed, unsigned, long, short

By default, numerical values in C are signed, which means that a bit of information is used to store the sign of the number. Negative numbers are stored different than you might expect: we use **two's complement**.

When a negative value is added to a positive number of the same magnitude, the result will be 0. In binary, that implies going all round back to 0, because binary numbers with fixed length work circulary. Thus, in order to get the negative number, one must invert all the bits of the number in question, then add one.
This can be explored quickly on a smaller scale using pcalc:

```
$ pcalc 0y01001001
  73                0x49                0y01001001
$ pcalc 0y10110110 + 1
  183             	0xb7              	0y10110111
$ pcalc 0y10110111 + 0y01001001
	256             	0x100              0y100000000

The program pcalc shows the value 256 because it’s not aware that we’re only dealing with 8-bit values. Which means, the 9th digit, counting from the right, may be 1, but we have come all the way back to 0 on the first 8.

In C, variables can be declared as unsigned by simply prepending the keyword unsigned to the declaration. In addition, the size of numerical variables can be extended or shortened by adding the keywords long or short.

Let's explore the macro ```sizeof()``` by means of datatype_sizes.c:

```
#include <stdio.h>
int main() {
printf("The 'int' data type is\t\t %d bytes\n", sizeof(int));
printf("The 'unsigned int' data type is\t %d bytes\n", sizeof(unsigned int));
printf("The 'short int' data type is\t %d bytes\n", sizeof(short int));
printf("The 'long int' data type is\t %d bytes\n", sizeof(long int));
printf("The 'long long int' data type is %d bytes\n", sizeof(long long int));
printf("The 'float' data type is\t %d bytes\n", sizeof(float));
printf("The 'char' data type is\t\t %d bytes\n", sizeof(char)); }
```
```

```
$ ./a.out
The 'int' data type is		 4 bytes
The 'unsigned int' data type is	 4 bytes
The 'short int' data type is	 2 bytes
The 'long int' data type is	 8 bytes
The 'long long int' data type is 8 bytes
The 'float' data type is	 4 bytes
The 'char' data type is		 1 bytes
```

#### Pointers
The RIP register is a pointer that points to the current instruction during a program's execution by containing its memory address. The idea of pointers is also used in C: they can be used like any other variable, prepending an asterisk to the variable name.

In pointers.c, we print "Hello, world", then print from the third character onwards "llo, world", and then we substitute that last part with "y you guys!" so that, when printing again the initial variable, it shows "Hey you guys".

Let's take a look at it with gdb. When the pointer is examined as a string, it's apparent that the given string is there, located at memory address 0x7fffffffe630 (using ```x/xw pointer```), and value "Hello, world\n" (using ```x/s pointer```). In order to use the value that the pointer __points to__, you must use the *unary operator*, &, prepended to a variable name.

(gdb) x/xw &pointer

0x7fffffffe620:	0xffffe630

(gdb) print &pointer

$1 = (char \*\*) 0x7fffffffe620

(gdb) print pointer
$2 = 0x7fffffffe630 "Hello, world\n"

When the address-of operator is used, the pointer variable is shown to be located at the address 0x7fffffffe620 in memory, and it contains the address 0xffffe630.

The address-of operator is often used in conjunction with pointers, since pointers contain memory addresses, like in addressof.c:

´´´c
#include <stdio.h>
int main() {
int int_var = 5; int \*int_ptr;
int_ptr = &int_var; // put the address of int_var into int_ptr
}
´´´

Using gdb:

(gdb) print &int_var

$2 = (int \*) 0x7fffffffe63c

(gdb) print int_ptr
$3 = (int \*) 0x7fffffffe63c

An additional unary operator called the dereference operator exists for use with pointers: \*.

(gdb) print \*int_ptr

$4 = 5

When the unary operators are used with pointers, the address-of oper- ator can be thought of as moving backward, while the dereference operator moves forward in the direction the pointer is pointing.


#### Format Strings

A format string is just a character string with special escape sequences that tell the function to insert variables printed in a specific format in palce of the scape sequence.

The way the printf() function has been used in the previous programmes, "Hello, world\n" string, technically is the format string, but without special scape sequences.

These escape sequences are called *format parameters*, and for each one the function is expected to take an additional argument:

%d - decimal
%u - unsigned decimal
%x - hexadecimal
%f - floating-point variable
%s - string
%n - number of bytes written so far


The %s expects a memory address. Let's put everything in context with fmt_strings.c

```
#include <stdio.h>

int main(){
  char string[10];
  int A = -73;
  unsigned int B = 31337;

  strcpy(string, "sample");

  // Example of printing with different format strings:
  printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);
  printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);
  printf("[field width on B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);
  printf("[string] %s Address %08x\n", string, string);

  // Example of unary address operator (dereferencing) and a %x format string
  printf("variable A is at address: %08x\n", &A);
}
```

./fmt_strings
[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
[field width on B] 3: '31337', 10: '     31337', '00031337'
[string] sample Address 5c7edd8e
variable A is at address: 5c7edd84


The third line in the example, labeled [field width on B], shows the use of the field-width option in a format parameter. This is just an integer that designates the minimum field width for that format parameter. However, this is not a maximum field width—if the value to be outputted is greater than the field width, the field width will be exceeded.

This happens when 3 is used, since the output data needs 5 bytes. When 10 is used as the field width, 5 bytes of blank space are outputted before the output data. Additionally, if a field width value begins with a 0, this means the field should be padded with zeros. When 08 is used, for example, the output is 00031337.

Format strings are used by an entire family of standard I/O functions, including scanf(), which basically works like printf() but for input. One key difference is that scanf() expects all of its arguments to be pointers, os the arguments must actually be variable addresses— not the variables themselves.

#### Typecasting

Typecasting is a simple way to temporarily change a variable's data type, despite how it was originally defined. When a variable is typecast into a different type, the compiler is told to treat that variable as if it were the new data type, but only for that operation.

Have you ever used integers and floating point variables altogether?

Let's see typecasting.c

```
#include <stdio.h>

int main(){
  int a, b;
  float c, d;

  a = 13;
  b = 5;

  c = a / b;
  d = (float) a / (float) b;

  printf("[integers]\t a = %d\t b = %d\n", a, b);
  printf("[floats]\t c = %f\t d = %f\n", c, d);
}
```

[integers]	 a = 13	 b = 5
[floats]	 c = 2.000000	 d = 2.600000

dividing integers will round down to the incorrect answer 2, even if the value is stored as a floating-point variable; you must divide floating points to get a float, which will allow for the correct calculation.

This example is illustrative, but where typecasting shines is when it is used with pointer variables.

Even though a pointer is just a memory address, C demands a data type for every pointer (it's trying to limit programming errors, which makes sense, but it's annoying). An integer pointer should only point to integer data, while a character pointer should only point to character data, and so on. Another reason is for pointer arithmetic. An integer is four bytes in size, while a character only takes up a single byte: when I do int_pointer + 1, the amount of bytes being added to the pointer is different than when I do char_pointer + 1.

Let's illustrate this with pointer_types.c:

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  char *char_pointer;
  int *int_pointer;

  char_pointer = char_array;
  int_pointer = int_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the integer %d\n", int_pointer, *int_pointer);
    int_pointer = int_pointer + 1;
  }

  for (i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the char %c\n", char_pointer, *char_pointer);
    char_pointer = char_pointer + 1;
  }
}
```

[integer pointer] points to 0x7ffd0f1cf510, which contains the integer 1
[integer pointer] points to 0x7ffd0f1cf514, which contains the integer 2
[integer pointer] points to 0x7ffd0f1cf518, which contains the integer 3
[integer pointer] points to 0x7ffd0f1cf51c, which contains the integer 4
[integer pointer] points to 0x7ffd0f1cf520, which contains the integer 5
[char pointer] points to 0x7ffd0f1cf533, which contains the char a
[char pointer] points to 0x7ffd0f1cf534, which contains the char b
[char pointer] points to 0x7ffd0f1cf535, which contains the char c
[char pointer] points to 0x7ffd0f1cf536, which contains the char d
[char pointer] points to 0x7ffd0f1cf537, which contains the char e

Check that out! The int_pointer moves in 4-byte steps, whereas char_pointer moves in 1-byte step, even though the same value of 1 is added to int_pointer and char_pointer in their respective loops.

What if I swap them?

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  char *char_pointer;
  int *int_pointer;


  // SWAP
  char_pointer = int_array;
  int_pointer = char_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the char %c\n", int_pointer, *int_pointer);
    int_pointer = int_pointer + 1;
  }

  for (i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the int %d\n", char_pointer, *char_pointer);
    char_pointer = char_pointer + 1;
  }
}
```

When compiling, I get the following warning: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types]


[integer pointer] points to 0x7ffcce291323, which contains the char a
[integer pointer] points to 0x7ffcce291327, which contains the char e
[integer pointer] points to 0x7ffcce29132b, which contains the char @
[integer pointer] points to 0x7ffcce29132f, which contains the char
[integer pointer] points to 0x7ffcce291333, which contains the char ?
[char pointer] points to 0x7ffcce291300, which contains the int 1
[char pointer] points to 0x7ffcce291301, which contains the int 0
[char pointer] points to 0x7ffcce291302, which contains the int 0
[char pointer] points to 0x7ffcce291303, which contains the int 0
[char pointer] points to 0x7ffcce291304, which contains the int 2

Even though int_pointer points to char data, it is still typed as an integer: adding 1 to it will increment the address by 4 each time, and you go from 'a' to 'e' on the very first step. Similarly, char_pointer address is only incremented by 1 each time, so it takes 4 steps to go from 1 to 2, going through all the little-endian representation of 1: 0x01, 0x00, 0x00, 0x00.

To fix this, we may use typecasting:

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  char *char_pointer;
  int *int_pointer;

  char_pointer = int_array;
  int_pointer = char_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the char %c\n", int_pointer, *int_pointer);
    int_pointer = (int *) ((char *) int_pointer + 1);
  }

  for (i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the int %d\n", char_pointer, *char_pointer);
    char_pointer = (char *) ((int *) char_pointer + 1);
  }
}
```

For int_pointer, I cast it as char pointer before adding 1, and then recast it as int. For char_pointer, I cast it as int before adding 1, and then recast it as char.

[integer pointer] points to 0x7ffe988e8e33, which contains the char a
[integer pointer] points to 0x7ffe988e8e34, which contains the char b
[integer pointer] points to 0x7ffe988e8e35, which contains the char c
[integer pointer] points to 0x7ffe988e8e36, which contains the char d
[integer pointer] points to 0x7ffe988e8e37, which contains the char e
[char pointer] points to 0x7ffe988e8e10, which contains the int 1
[char pointer] points to 0x7ffe988e8e14, which contains the int 2
[char pointer] points to 0x7ffe988e8e18, which contains the int 3
[char pointer] points to 0x7ffe988e8e1c, which contains the int 4
[char pointer] points to 0x7ffe988e8e20, which contains the int 5

Naturally, it's way easier to just use the correct data types in the first place; sometimes a generic pointer is desired, like the void pointer.

We can modify pointer_types3.c to use a single pointer by typecasting it to the proper type each time it's used:

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  void *void_pointer;

  void_pointer (void *) char_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the char %c\n", void_pointer, *((char *) void_pointer));
    void_pointer = (void *)((char*) void_pointer + 1);
  }

  void_pointer = (void *) int_array;

  for i(i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the int %d\n", void_pointer, *((int *) void_pointer));
    void_pointer = (void *)((int *) void_pointer + 1);
  }
}
```

All of this results in the same outcome. The void pointer is really just holding memory addresses, while the hard-coded typecasting is responsible to give meaning to that + 1 on the iteration.

But we can also use anything that can store a 4-byte value as memory. How about an unsigned integer?

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  unsigned int hacky_nonpointer;

  hacky_nonpointer = (unsigned int) char_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the char %c\n", unsigned_int, *((char *) unsigned_int));
    hacky_nonpointer = hacky_nonpointer + sizeof(char);
  }

  hacky_nonpointer = (unsigned int) int_array;


  for (i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the int %d\n", unsigned_int, *((int *) unsigned_int));
    hacky_nonpointer = hacky_nonpointer + sizeof(int);
  }
}
```

All of this is very hacky, but the typecasting enables us with the power to extend what we're capable of doing with unsigned ints.

#### Command-Line Arguments

Many non-graphical programs receive input in the form of command-line arguments. They don't require user interaction after execution has begun: it's more efficient.

In C, command-line arguments can be accessed in the main() function by including two additional arguments to the function: an integer and a pointer to an array of strings.

Like this:

```
#include <stdio.h>

int main(int arg_count, char *arg_list[]){
  int i;
  printf("There were %d arguments provided:\n", arg_count);
  for (i=0; i<arg_count; i++){
    printf("argument #%d\t-\t%s\n", i, arg_list[i]);
  }
}
```
The zeroth argument is always the name of the executing binary, and the rest of the argument array (often called an argument vector) contains the remaining arguments as strings.

```sh
./commandline this is a test
There were 5 arguments provided:
argument #0	-	./commandline
argument #1	-	this
argument #2	-	is
argument #3	-	a
argument #4	-	test
```

Given that the arguments are always strings, one may want to convert it into an integer to manipulate results. In order to do so we can use atoi(), as in ASCII to integer:

```c
#include <stdio.h>
#include <stdlib.h>

void usage(char *program_name){
  printf("Usage %s <message> <# of times to repeat>\n", program_name);
  exit(1);
}


int main(int argc, char *argv[]){
  int i, count;

  if (argc <3){
    usage(argv[0]); // If there are fewer than 3 arguments, exit!
  };

  count = atoi(argv[2]);
  printf("Repeating %d times...\n", count);

  for (i=0; i < count; i++){
    printf("%3d - %s\n", i, argv[1]); // print the first argument
  }
}
```
```sh
root@hacker:/app# ./a.out
Usage ./a.out <message> <# of times to repeat>
root@hacker:/app# ./a.out "Hello!" 3
Repeating 3 times...
  0 - Hello!
  1 - Hello!
  2 - Hello!
```

Notice that we must consider the possibility that the argument count is less than 3, given that we are accessing argv[1]. If we trieed to continue with the operations without providing at least 3 arguments, the program would try to access a part of memory that's outside the program's scope. In C it’s important to check for these types of conditions and handle them in program logic.

If we comment that if statement, we'll see what happens:

```sh
root@5cf102276c99:/app# gcc convert2.c
root@5cf102276c99:/app# ./a.out "Hello!" 3
Repeating 3 times...
  0 - Hello!
  1 - Hello!
  2 - Hello!
root@5cf102276c99:/app# ./a.out
Repeating 0 times...
root@5cf102276c99:/app# ./a.out test
Segmentation fault
```

Segmentation fault is precisely that: the program is trying to access memory that isn't allowed to. Memory is split into segments (which will be discussed later), and some memory addresses aren’t within the boundaries of the memory segments the program is given access to. When the program attempts to access an address that is out of bounds, it will crash and die in what’s called a segmentation fault. This effect can be explored further with GDB:

```
(gdb) run test
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /app/a.out test

Breakpoint 1, 0x00005555555546fc in main ()
(gdb) x/3xw 0x00005555555546fc
0x5555555546fc <main+4>:	0x20ec8348	0x48ec7d89	0x48e07589
(gdb) x/s 0x20ec8348
0x20ec8348:	<error: Cannot access memory at address 0x20ec8348>
(gdb) x/s 0x48ec7d89
0x48ec7d89:	<error: Cannot access memory at address 0x48ec7d89>
(gdb) x/s 0x48e07589
0x48e07589:	<error: Cannot access memory at address 0x48e07589>
(gdb) c   
Continuing.

Program received signal SIGSEGV, Segmentation fault.
__GI_____strtol_l_internal (nptr=0x0, endptr=endptr@entry=0x0,
    base=base@entry=10, group=group@entry=0,
    loc=0x7ffff7dd0560 <_nl_global_locale>) at ../stdlib/strtol_l.c:292
292	../stdlib/strtol_l.c: No such file or directory.
```

Since the argument vector is a pointer to list of strings, it is actually a pointer to a list of pointers. Using the command x/3xw to examine the first three memory addresses stored at the argument vector’s address shows that they are themselves pointers to strings. When the program tries to access this memory addresses, it crashes with a segmentation fault.

#### Variable scoping

Another interesting concept regarding memory in C is variable scoping or context—in particular, the contexts of variables within functions. Each function has its own set of variables, even if it's the same function being called a bit later. Let's check it out:

```
#include <stdio.h>

void func3(){
  int i = 11;
  printf("\t\t\t[in func3] i = %d\n", i);
};

void func2(){
  int i = 7;
  printf("\t\t[in func2] i = %d\n", i);
  func3();
  printf("\t\t[back in func2] i = %d\n", i);
};

void func1(){
  int i = 5;
  printf("\t[in func1] i = %d\n", i);
  func2();
  printf("\t[back in func1] i = %d\n", i);
};

int main(){
  int i = 3;
  printf("[in main] i = %d\n", i);
  func1();
  printf("[back in main] i = %d\n", i);
};

```

When compiling and executing, this is what we get:

[in main] i = 3
	[in func1] i = 5
		[in func2] i = 7
			[in func3] i = 11
		[back in func2] i = 7
	[back in func1] i = 5
[back in main] i = 3

i takes different value depending on the context in which we call the function. Even if they're all called i, they aren't the same variable. They aren't __global__; although they could be.

Let's set j outside func1, func2, and func3, but *also* setting j inside func2, like we did in scope2, to see:

```
[in main] i = 3, j = 42
	[in func1] i = 5, j = 42
		[in func2] i = 7, j = 42
		[in func2] setting j = 1337
			[in func3] i = 11, j = 999
		[back in func2] i = 7, j = 1337
	[back in func1] i = 5, j = 1337
[back in main] i = 3, j = 1337
```

In the output, the global variable j is written to in func2(), and the change persists in all functions except func3() , which has its own local variable called j. The compiler makes the local variable take precedence over the global one.

With all these variables using the same names, it can be a little confusing, but remember that in the end, it’s all just memory. The local variables for each function are each stored in their own places in memory, regardless of the identical names.

Let's print the memory addresses to make this explicit.

```
[in main] i @ 0xaefcd384 = 3
[in main] j @ 0xfc058010 = 42
	[in func1] i @ 0xaefcd364 = 5
	[in func1] j @ 0xfc058010 = 42
		[in func2] i @ 0xaefcd344 = 7
		[in func2] j @ 0xfc058010 = 42
		[in func2] setting j = 1337
			[in func3] i @ 0xaefcd320 = 11
			[in func3] j @ 0xaefcd324 = 999
		[back in func2] i @ 0xaefcd344 = 7
		[back in func2] j @ 0xfc058010 = 1337
	[back in func1] i @ 0xaefcd364 = 5
	[back in func1] j @ 0xfc058010 = 1337
[in main] j @ 0xfc058010 = 1337
[back in main] j @ 0xfc058010 = 1337
```

i is stored, at the same time, in 0xaefcd384, 0xaefcd364, 0xaefcd344 and 0xaefcd320. j is stored in 0xfc058010 all the time, except in func3, where it's stored in 0xaefcd324. That makes perfect sense; the compiler is reserving memory for each local variable on the stack, *regardless of their name*. Only a global variable would reuse the memory address because it's the same variable all along.

Each time a function is called, a record called a stack frame is put on the stack. They are, for all use and purposes, completely different functions in terms of memory.

In addition to globals, variables can also be defined as **static** variables by prepending the keyword static to the variable definition. Similar to global variables, a static variable remains intact between function calls; however, static variables are also akin to local variables since they remain local within a particular function context. One different and unique feature of static variables is that they are only initialized once. The code in static.c will help explain these concepts.

Let's see static in action:

```
#include <stdio.h>

void function(){
  int var = 5;
  static int static_var = 5; // Static variable initialisation

  printf("\t[in function] var = %d\n", var);
  printf("\t[in function] static_var = %d\n", static_var);
  var++; // Add one to var.
  static_var++; // Add one to static_var.
}

int main(){
  int i;
  static int static_var = 1337; // Another static, in a different context

  for(i=0; i<5; i++){
    printf("[in main] static_var = %d\n", static_var);
    function(); // Call the function.
  }
}
```

What we are trying to do is see what happens when we initialise static and non static variables outside the context in which they were created.


```
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 5
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 6
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 7
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 8
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 9
```

The aptly named static_var is defined as a static variable in two places: within the context of main() and within the context of function(). Since static variables are local within a particular functional context, these variables can have the same name, but they actually represent two different locations in memory. Notice that **the static_var retains its value between subsequent calls to function()**: static variables are only initialised once, being local to a particular function context.

[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 5
[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 6
[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 7
[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 8
[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 9

In memory, of course, the variable static_var is placed in two memory addresses along the way: one for the main context, 0x804968c, and the second one for the function context, 0x8049688.

### Memory Segmentation

A compiled program’s memory is divided into five segments:

- text
- data
- bss
- heap
- stack

Each segment represents a special portion of memory that is set aside for a certain purpose.

The __text segment__, or code segment, is where the assembled machine language instructions of the program are located. The execution of instructions in this segment is nonlinear, thanks to the high-level control structures (if, for, while, and so on) that eventually compile into branch, jump, and call instructions in assembly language.

As a program executes, the RIP is set to the first instruction in the text segment. The processor then follows an execution loop that does the following:

1. Reads the instruction that EIP is pointing to.
2. Adds the byte length of the instruction to RIP.
3. Executes the instruction that was read in step 1.
4. Goes back to step 1.

Write permission is disabled in the text segment, as it is not used to store variables, only code. This *prevents people from actually modifying the program code*; any attempt to write to this segment of memory will kill the program. Another advantage of this segment being read-only is that it *can be shared among different copies of the program*, allowing multiple executions of the program at the same time without any problems.

The data and bss segments are used to store global and static programme variables. The __data segment__ is filled with the initialised global and static variables, while the __bss segment__ is filled with their uninitialised counterparts. They are writable, but have fixed size: global variables are, thus, persistent, and they do persist because they are stored here.

The __heap segment__ is a segment that the programmer can directly control. Blocks can be allocated for whatever he or she needs to. It can grow larger or smaller as needed, and all of it is managed by the allocator and deallocator algorithms: a programmer using the heap can reserve and free memory on the fly. The growth of the heap moves downward toward higher memory addresses.

The __stack segment__ also has variable size and is used as a temporary scratch pad to store local function variables and context during function calls. This is where GDB backtrace looks at. Each function's context, its own set of variables and the RIP address and where it should go after the function has completed, is stored together on the stack in what is called *stack frame*. As the name implies, the stack segment of memory is a stack data structure, which piles up stack frames on top of each other. The RSP register is used to keep track of the address of the end of the stack, which is constantly changing as items are pushed into and popped off of it. It grows upward in a visual listing of memory, toward lower memory addresses.

The stack is First In Last Out; it makes sense because it's used to store context, which piles up like the code goes from left to right. When a function is called, the RBP register is used to reference local function variables in the current stack frame. Each frame contains the parameters, its local variables, and two pointers: the saved frame, or SFP, which stores the previous RBP, and the return address, which restores RIP to the next instruction found after the function call.

Let's see this with an example:

```c
void test_function(int a, int b, int c, int d){
  int flag;
  char buffer[10];

  flag = 31337;
  buffer[0] = 'A';
}

int main(){
  test_function(1,2,3,4);
}
```

The memory for the test_function variables is in the stack segment, while the machine instructions for the function's code is in the text segment. Let's see this with GDB.

```
(gdb) disass main
Dump of assembler code for function main:
   0x00000000000006af <+0>:	push   rbp
   0x00000000000006b0 <+1>:	mov    rbp,rsp
   0x00000000000006b3 <+4>:	mov    ecx,0x4
   0x00000000000006b8 <+9>:	mov    edx,0x3
   0x00000000000006bd <+14>:	mov    esi,0x2
   0x00000000000006c2 <+19>:	mov    edi,0x1
   0x00000000000006c7 <+24>:	call   0x66a <test_function>
   0x00000000000006cc <+29>:	mov    eax,0x0
   0x00000000000006d1 <+34>:	pop    rbp
   0x00000000000006d2 <+35>:	ret    
End of assembler dump.
(gdb) disass test_function
Dump of assembler code for function test_function:
   0x000000000000066a <+0>:	push   rbp
   0x000000000000066b <+1>:	mov    rbp,rsp
   0x000000000000066e <+4>:	sub    rsp,0x30
   0x0000000000000672 <+8>:	mov    DWORD PTR [rbp-0x24],edi
   0x0000000000000675 <+11>:	mov    DWORD PTR [rbp-0x28],esi
   0x0000000000000678 <+14>:	mov    DWORD PTR [rbp-0x2c],edx
   0x000000000000067b <+17>:	mov    DWORD PTR [rbp-0x30],ecx
   0x000000000000067e <+20>:	mov    rax,QWORD PTR fs:0x28
   0x0000000000000687 <+29>:	mov    QWORD PTR [rbp-0x8],rax
   0x000000000000068b <+33>:	xor    eax,eax
   0x000000000000068d <+35>:	mov    DWORD PTR [rbp-0x18],0x7a69
   0x0000000000000694 <+42>:	mov    BYTE PTR [rbp-0x12],0x41
   0x0000000000000698 <+46>:	nop
   0x0000000000000699 <+47>:	mov    rax,QWORD PTR [rbp-0x8]
   0x000000000000069d <+51>:	xor    rax,QWORD PTR fs:0x28
   0x00000000000006a6 <+60>:	je     0x6ad <test_function+67>
   0x00000000000006a8 <+62>:	call   0x540 <__stack_chk_fail@plt>
   0x00000000000006ad <+67>:	leave  
   0x00000000000006ae <+68>:	ret    
End of assembler dump.
```

main() starts at 0x00000000000006af and test_function starts at 0x000000000000066a. The first few functions (up to main+1 and test_function+4) set up the stack frame, and are called *procedure prologue*, and they're there to save the frame pointer on the stack, while saving stack memory for the local function variables.

When the test_function is called, the various values are pushed to the stack to create the start of the stack frame as follows: the function arguments are pushed onto the stack in reverse order, so in this case it will push 4, then 3, then 2, then 1. Did you see main+4 all the way through main+19? It's assigning values to ECX, EDX, ESI, EDI, which will store the values that the next instruction, call test_function, will need.

Next, when the assembly call instruction is executed, the return address is pushed onto the stack, and the execution flow jumps to the start of the test_function, at 0x66a. The return value will be the location of the instruction, following the current RIP.

The call instruction both stores the return address on the stack and jumps RIP to the beginning of test_function, so test_function's procedure prologue instructions finish building the stack frame. In this step, the current value of RBP is pushed to the stack (see 66a): this value is called the saved frame pointer (SFP), and it's later used to restore RBP when we leave.

The current value of RSP is then copied to RBP (see 66b) to set the new frame pointer. This frame pointer is used to reference the local variables of the function, flag and bugger. Memory is saved for these variables by substracting from RSP (see 66e, where 0x30 is substracted. 0x30 is 16*3 = 48 bytes. 40 bytes for the 10 char string, + 8 bytes for the int. Everything seems to make sense).

In the end, the stack frame looks something like this:

| Top of the Stack        |
|:-------------:|
| buffer     |
| flag      |
| saved frame pointer (SFP) |
| return address (and above, the frame pointer RBP)   |
|a   |
|b   |
|c   |
|d   |
|...   |
