# Art of Exploitation

- Hackers get their edge from knowing how all the pieces interact within the bigger picture.

- Thinking of C-source as a program is a common misconception that is exploited by hackers every day. As long as the compiled program works, the average programmer is only concerned with source code. But a hacker realizes that the compiled program is what actually gets executed out in the real world.

- Most hacker exploits are a lot like magic tricks—they seem amazing and magical, unless you know about sleight of hand and misdirection.

## Programming

### firstprog.c & firstprog.txt

The hexadecimal numbers— 100000f40— are memory addresses. Like a row of houses on a local street, memory can be thought of as a row of bytes, each with its own memory address.

The hexadecimal bytes in the middle are the machine language instructions for the processor. The machine code is displayed as bytes and each instruction is put on its own line, like splitting a paragraph into sentences.

The instructions on the far right are in assembly language; a collection of mnemonics for the corresponding machine language instructions. Assembly language instructions have a direct one-to-one relationship with their corresponding machine language instruction; each processor has a different form of assembly language. While you can theoretically create your own x86 assembly language syntax, most people stick with one of the two main types: AT&T syntax and Intel syntax. It’s easy to recognize AT&T syntax by the cacophony of % and $ symbols prefixing everything.

### GDB
Inside Docker: ```docker run --rm -v $(pwd):/app ubuntu:latest bash```

```gdb -q ./a.out```

#### General purpose registers:

- rax: Accumulator
- rbx: Base
- rcx: Counter
- rdx: Data

Temporary variables for the CPU

#### Pointers and indexes

- rsi: Source Index
- rdi: Destination Index
- rbi: Base Pointer
- rsi: Stack Pointer

Pointers store memory addresses; Indexes point to source and destination where data needs to be read from or written to.

### Instruction Pointer

- rip: Instruction Pointer

Like a child pointing his finger at each word as he reads, the processor reads each instruction using the RIP register as finger.

At first, it points at 0x5648307eb63e. Check out firstprog-Intel-ubuntu: the first memory address is 63a!

Now, what is 63b and 63e doing:

63b:	48 89 e5             	mov    rbp,rsp
63e:	48 83 ec 10          	sub    rsp,0x10

The assembly instructions in Intel syntax generally follow this style: operation <destination>, <source>. Mov will move a value from the source to destination, sub will subtract, inc will increment, etc.

- gdb break main ... run ... info registers rip

First, the breakpoint is set at the start of main(), and the program is run. Since the breakpoint has been set at the start of main, the program hits the breakpoint and pauses before actually executing any instructions in main.

notice that ```info register rip``` points to an instruction in the main() function's disassembly (the fourth, to be precise). The instruction before this are collectively known as the *function prologue* and aer generated to set up memory for the rest of the main function local variables. In fact, we declare. variables in C in order to aid the construction of this prologue.

The debugger knows this, and skips over this part.

- Examine memory using ```x```

The default size of a single unit is a four byte unit called a *word*. This is confusing because sometimes it also refers to a 2 byte value, and thus a DWORD, or double word refers to a 4-byte value. We'll use word and DWORD interchangeably.

b - single byte
h - halfword, two bytes
w - word, four bytes
g - giant, eight bytes

And the format:

o - octal
x - hexadecimal 
u - unsigned, standard decimal
t - binary

A number can also be prepended to the format of the examine command to examine multiple units at the target address.

You can try ```x/8xb $rip```. This is what you may get:

(gdb) x/8xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00	0xeb

(gdb) x/8xh $rip

0x563dfc6f1642 <main+8>:	0x45c7	0x00fc	0x0000	0xeb00	0x4810	0x3d8d	0x00a2	0x0000

(gdb) x/8xw $rip

0x563dfc6f1642 <main+8>:	0x00fc45c7	0xeb000000	0x3d8d4810	0x000000a2

0x563dfc6f1652 <main+24>:	0xfffeb9e8	0xfc4583ff	0xfc7d8301	0xb8ea7e09


Now, you may have noticed that those commands that use bigger units display more data. However, x/8xb showed the first two bytes to be 0xc7 and 0x45, __but__ x/8xh showed that memory address to be 0x45c7, and x/8xw also shows 0x00fc45c7, which keeps reversing the two memory addresses showed in x/8xh.

In the x86 processor, values are stored in *little-endian* byte order, which means that the least significant byte is stored first. GDB is simply smart enough to know how values are stored, so when a word or halfword is examined, the bytes must be reversed.

Revisiting these values displayed both as hexadecimal and unsigned decimals might help clear up any confusion.

(gdb) x/4xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00

(gdb) x/4ub $rip

0x563dfc6f1642 <main+8>:	199	69	252	0

(gdb) x/1uw $rip

0x563dfc6f1642 <main+8>:	16532935

Notice this: 199 * (256^3) + 69 * (256^2) + 252 * (256^1) + 0 = 3343252480 WRONG!

But: 0 * (256^3) + 252 * (256^2) + 69 * (256^1) + 199 = 16532935 RIGHT!


GDB can also disassemble machine language into assembly instructions, with the command ```i```:

(gdb) x/i $rip

=> 0x563dfc6f1642 <main+8>:	movl   $0x0,-0x4(%rbp)

(gdb) x/3i $rip

=> 0x563dfc6f1642 <main+8>:	movl   $0x0,-0x4(%rbp)
   0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>
   0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4

Since the RIP register points to memory that contains machine language instructions, they disassemble nicely, and matches what we did with ```objdump``` (check out lines 4 to 6 in firstprog-ATT-ubuntu).

The first instruction will move the value of 0x0 (0, obviously) into memory located at the address stored in the RBP register, minus 0x4 (4, ditto). That's where the C variable ```i``` is stored! And the 4 is exactly the size of an integer on the x86 processor! It follows that this command will zero out the variable i for the for loop.

The memory at this location can be examined in several ways:

(gdb) i r $rbp

rbp            0x7ffe3e65d3d0	0x7ffe3e65d3d0

(gdb) x/4xb $rbp - 4

0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(gdb) x/4xb $rbp - 4
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

Oh, wow. The book was expecting random garbage, but I can see that the variable is initialised as 0. Looking at this [question from SO](https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value), it doesn't make any sense.

Ah, wait. I did initialised the variable, ```for (i=0....)```! My Mac is probably misbehaving, or I'm using a version of C that outdated this book.

Now, if $rbp ends in d0, then 4 bytes before in terms of address is cc (-1byte is cf, -2 is ce, -3 is cd, then -4 is cc). So the address showed is correct and in fact:

(gdb) x/4b 0x7ffe3e65d3cc
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(gdb) print $rbp -4
$1 = (void *) 0x7ffe3e65d3cc


(gdb) x/4b $1
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

print also allows us to both print a particular value in a certain address and store that address on a variable.


---

Let's execute the current instruction using the command ```nexti```. The processor will read RIP, execute it, and advance RIP to the next instruction address.

(gdb) nexti
0x0000563dfc6f1649	6	    for(i=0; i < 10; i++){

(gdb) x/4xb $1
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(Now it displays 0, again!)

(gdb) i r $rip
rip            0x563dfc6f1649	0x563dfc6f1649 <main+15>

(gdb) x/i $rip
=> 0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>

i = 0, and RIP goes to the next instruction:

(gdb) x/10i $rip
=> 0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>
   0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4
   0x563dfc6f1652 <main+24>:	callq  0x563dfc6f1510 <puts@plt>
   0x563dfc6f1657 <main+29>:	addl   $0x1,-0x4(%rbp)
   0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)
   0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>
   0x563dfc6f1661 <main+39>:	mov    $0x0,%eax
   0x563dfc6f1666 <main+44>:	leaveq 
   0x563dfc6f1667 <main+45>:	retq   
   0x563dfc6f1668:	nopl   0x0(%rax,%rax,1)

First, jump to 65b. That's easy: it's the instruction below, the one that says ```cmp```. It's a compare instruction, number 0x9 with what's stored in $rbp - 0x04.
The next is ```jle```, jump if less or equal, which combined with the previous means that if variable i is less or equal than 9, then jump tp 64b. Since we know that i is now 0, we are going to be directed to that 64b. At least for now.

(gdb) nexti

0x0000563dfc6f165b	6	    for(i=0; i < 10; i++){

(gdb) x/i $rip

=> 0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)

(gdb) x/i $rip

=> 0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>

Now, next instruction:

(gdb) nexti

7	        puts("Hello, world\n");

(gdb) i r $rip

rip            0x563dfc6f164b	0x563dfc6f164b <main+17>

(gdb) x/2i $rip
=> 0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4

   0x563dfc6f1652 <main+24>:	callq  0x563dfc6f1510 <puts@plt>

So yes, 64b, and the instruction ```lea```. That's Load Effective Address, which means that the value in RIP + 0xa2 is moved onto $RDI. It's like a mov, but with memory addresses (the old book keeps the mov, it's perhaps the version of the compiler.
