# Art of Exploitation

In order to hack away in a tested environment, do the following:

1. Install [Docker](https://itnext.io/docker-101-fundamentals-the-dockerfile-b33b59d0f14b)
2. ```docker build -t exploitation:latest .```
3. ```docker run -it --cap-add=SYS_PTRACE --security-opt seccomp=unconfined exploitation:latest bash```
4. Inside GDB, do ```set disassembly-flavor intel```.

- Hackers get their edge from knowing how all the pieces interact within the bigger picture.

- Thinking of C-source as a program is a common misconception that is exploited by hackers every day. As long as the compiled program works, the average programmer is only concerned with source code. But a hacker realizes that the compiled program is what actually gets executed out in the real world.

- Most hacker exploits are a lot like magic tricks—they seem amazing and magical, unless you know about sleight of hand and misdirection.

## Programming

### firstprog.c & firstprog.txt

The hexadecimal numbers— 100000f40— are memory addresses. Like a row of houses on a local street, memory can be thought of as a row of bytes, each with its own memory address.

The hexadecimal bytes in the middle are the machine language instructions for the processor. The machine code is displayed as bytes and each instruction is put on its own line, like splitting a paragraph into sentences.

The instructions on the far right are in assembly language; a collection of mnemonics for the corresponding machine language instructions. Assembly language instructions have a direct one-to-one relationship with their corresponding machine language instruction; each processor has a different form of assembly language. While you can theoretically create your own x86 assembly language syntax, most people stick with one of the two main types: AT&T syntax and Intel syntax. It’s easy to recognize AT&T syntax by the cacophony of % and $ symbols prefixing everything.

### GDB
Inside Docker: ```docker run -it  --rm -v $(pwd):/app ubuntu:latest bash``` (remember to do apt-get build-essentials gdb to have gdb and gcc)

```gdb -q ./a.out```

#### General purpose registers:

- rax: Accumulator
- rbx: Base
- rcx: Counter
- rdx: Data

Temporary variables for the CPU

#### Pointers and indexes

- rsi: Source Index
- rdi: Destination Index
- rbi: Base Pointer
- rsi: Stack Pointer

Pointers store memory addresses; Indexes point to source and destination where data needs to be read from or written to.

### Instruction Pointer

- rip: Instruction Pointer

Like a child pointing his finger at each word as he reads, the processor reads each instruction using the RIP register as finger.

At first, it points at 0x5648307eb63e. Check out firstprog-Intel-ubuntu: the first memory address is 63a!

Now, what is 63b and 63e doing:

63b:	48 89 e5             	mov    rbp,rsp
63e:	48 83 ec 10          	sub    rsp,0x10

The assembly instructions in Intel syntax generally follow this style: operation <destination>, <source>. Mov will move a value from the source to destination, sub will subtract, inc will increment, etc.

- gdb break main ... run ... info registers rip

First, the breakpoint is set at the start of main(), and the program is run. Since the breakpoint has been set at the start of main, the program hits the breakpoint and pauses before actually executing any instructions in main.

notice that ```info register rip``` points to an instruction in the main() function's disassembly (the fourth, to be precise). The instruction before this are collectively known as the *function prologue* and aer generated to set up memory for the rest of the main function local variables. In fact, we declare. variables in C in order to aid the construction of this prologue.

The debugger knows this, and skips over this part.

- Examine memory using ```x```

The default size of a single unit is a four byte unit called a *word*. This is confusing because sometimes it also refers to a 2 byte value, and thus a DWORD, or double word refers to a 4-byte value. We'll use word and DWORD interchangeably.

b - single byte
h - halfword, two bytes
w - word, four bytes
g - giant, eight bytes

And the format:

o - octal
x - hexadecimal
u - unsigned, standard decimal
t - binary

A number can also be prepended to the format of the examine command to examine multiple units at the target address.

You can try ```x/8xb $rip```. This is what you may get:

(gdb) x/8xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00	0xeb

(gdb) x/8xh $rip

0x563dfc6f1642 <main+8>:	0x45c7	0x00fc	0x0000	0xeb00	0x4810	0x3d8d	0x00a2	0x0000

(gdb) x/8xw $rip

0x563dfc6f1642 <main+8>:	0x00fc45c7	0xeb000000	0x3d8d4810	0x000000a2

0x563dfc6f1652 <main+24>:	0xfffeb9e8	0xfc4583ff	0xfc7d8301	0xb8ea7e09


Now, you may have noticed that those commands that use bigger units display more data. However, x/8xb showed the first two bytes to be 0xc7 and 0x45, __but__ x/8xh showed that memory address to be 0x45c7, and x/8xw also shows 0x00fc45c7, which keeps reversing the two memory addresses showed in x/8xh.

In the x86 processor, values are stored in *little-endian* byte order, which means that the least significant byte is stored first. GDB is simply smart enough to know how values are stored, so when a word or halfword is examined, the bytes must be reversed.

Revisiting these values displayed both as hexadecimal and unsigned decimals might help clear up any confusion.

(gdb) x/4xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00

(gdb) x/4ub $rip

0x563dfc6f1642 <main+8>:	199	69	252	0

(gdb) x/1uw $rip

0x563dfc6f1642 <main+8>:	16532935

Notice this: 199 * (256^3) + 69 * (256^2) + 252 * (256^1) + 0 = 3343252480 WRONG!

But: 0 * (256^3) + 252 * (256^2) + 69 * (256^1) + 199 = 16532935 RIGHT!


GDB can also disassemble machine language into assembly instructions, with the command ```i```:

(gdb) x/i $rip

=> 0x563dfc6f1642 <main+8>:	movl   $0x0,-0x4(%rbp)

(gdb) x/3i $rip

=> 0x563dfc6f1642 <main+8>:	movl   $0x0,-0x4(%rbp)
   0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>
   0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4

Since the RIP register points to memory that contains machine language instructions, they disassemble nicely, and matches what we did with ```objdump``` (check out lines 4 to 6 in firstprog-ATT-ubuntu).

The first instruction will move the value of 0x0 (0, obviously) into memory located at the address stored in the RBP register, minus 0x4 (4, ditto). That's where the C variable ```i``` is stored! And the 4 is exactly the size of an integer on the x86 processor! It follows that this command will zero out the variable i for the for loop.

The memory at this location can be examined in several ways:

(gdb) i r $rbp

rbp            0x7ffe3e65d3d0	0x7ffe3e65d3d0

(gdb) x/4xb $rbp - 4

0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(gdb) x/4xb $rbp - 4
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

Oh, wow. The book was expecting random garbage, but I can see that the variable is initialised as 0. Looking at this [question from SO](https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value), it doesn't make any sense.

Ah, wait. I did initialised the variable, ```for (i=0....)```! My Mac is probably misbehaving, or I'm using a version of C that outdated this book.

Now, if $rbp ends in d0, then 4 bytes before in terms of address is cc (-1byte is cf, -2 is ce, -3 is cd, then -4 is cc). So the address showed is correct and in fact:

(gdb) x/4b 0x7ffe3e65d3cc
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(gdb) print $rbp -4
$1 = (void *) 0x7ffe3e65d3cc


(gdb) x/4b $1
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

print also allows us to both print a particular value in a certain address and store that address on a variable.


---

Let's execute the current instruction using the command ```nexti```. The processor will read RIP, execute it, and advance RIP to the next instruction address.

(gdb) nexti
0x0000563dfc6f1649	6	    for(i=0; i < 10; i++){

(gdb) x/4xb $1
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(Now it displays 0, again!)

(gdb) i r $rip
rip            0x563dfc6f1649	0x563dfc6f1649 <main+15>

(gdb) x/i $rip
=> 0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>

i = 0, and RIP goes to the next instruction:

(gdb) x/10i $rip
=> 0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>
   0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4
   0x563dfc6f1652 <main+24>:	callq  0x563dfc6f1510 <puts@plt>
   0x563dfc6f1657 <main+29>:	addl   $0x1,-0x4(%rbp)
   0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)
   0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>
   0x563dfc6f1661 <main+39>:	mov    $0x0,%eax
   0x563dfc6f1666 <main+44>:	leaveq
   0x563dfc6f1667 <main+45>:	retq   
   0x563dfc6f1668:	nopl   0x0(%rax,%rax,1)

First, jump to 65b. That's easy: it's the instruction below, the one that says ```cmp```. It's a compare instruction, number 0x9 with what's stored in $rbp - 0x04.
The next is ```jle```, jump if less or equal, which combined with the previous means that if variable i is less or equal than 9, then jump tp 64b. Since we know that i is now 0, we are going to be directed to that 64b. At least for now.

(gdb) nexti

0x0000563dfc6f165b	6	    for(i=0; i < 10; i++){

(gdb) x/i $rip

=> 0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)

(gdb) x/i $rip

=> 0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>

Now, next instruction:

(gdb) nexti

7	        puts("Hello, world\n");

(gdb) i r $rip

rip            0x563dfc6f164b	0x563dfc6f164b <main+17>

(gdb) x/2i $rip
=> 0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4

   0x563dfc6f1652 <main+24>:	callq  0x563dfc6f1510 <puts@plt>

So yes, 64b, and the instruction ```lea```. That's Load Effective Address, which means that the value in RIP + 0xa2 is moved onto $RDI. It's like a mov, but with memory addresses (the old book keeps the mov, it's perhaps the version of the compiler.

But what's so special about storing $RIP + 0xa2 into $RDI?? What is RDI pointing at?

(gdb) x/6xb $rdi

0x563dfc6f16f4:	0x48	0x65	0x6c	0x6c	0x6f	0x2c

(gdb) x/6cb $rdi

0x563dfc6f16f4:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	44 ','

(gdb) x/s $rdi

0x563dfc6f16f4:	"Hello, world\n"

Neat! It stores the string "Hello world"!

Remember, in the AoE book:

- ESP = RDI

- EIP = RIP

So if I do ```n``` (for next):

(gdb) n  
Hello, world

6	    for(i=0; i < 10; i++){

Bum! It prints the string!

What are the next three instructions?

(gdb) x/2i $rip
=> 0x563dfc6f1657 <main+29>:	addl   $0x1,-0x4(%rbp)

   0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)

   0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>

One means add 1 into what's stored in $RBP -4 (variable i, remember?). The second one compares, once again, the variable i and 9. And the third acts upon that comparison: again, if i is less than or equal to 9, go to 64b, and start again. That's the for loop, in action.

That's "hello, world." -- drop mic.

### Back to basics

#### Strings

Did you noticed? $rdi, in line 7, points to 0x563dfc6f16f4, which stored the value 0x48. That's when we did ```x/6cb``` and realised that the next 6 bytes referred to H, e, l, l, o, and so on. The variable wasn't a string: it was a pointer to the first letter. When calling callq on [puts](http://www.cplusplus.com/reference/cstdio/puts/), "The function begins copying from the address specified (str) until it reaches the terminating null character ('\0'). This terminating null-character is not copied to the stream."

I'm not in a position to actually look inside but we're close enough to the machine already.

In order to see it, we'll run char_array.c with the debugger:


```
#include <stdio.h>
int main()
{
char str_a[20];
 str_a[0] = 'H';
 str_a[1] = 'e';
 str_a[2] = 'l';
 str_a[3] = 'l';
 str_a[4] = 'o';
 str_a[5] = ',';
 str_a[6] = ' ';
 str_a[7] = 'w';
 str_a[8] = 'o';
 str_a[9] = 'r';
 str_a[10] = 'l';
 str_a[11] = 'd';
 str_a[12] = '!';
 str_a[13] = '\n';
 str_a[14] = 0;
 printf(str_a);
}
```


The first thing to be noticed is the warning when compiling it:

warning: format string
      is not a string literal (potentially
      insecure) [-Wformat-security]

The debugger is noticing something weird: it's not a string, but a list. However, it's not stopping the compiler from doing its job, so let's push it.


When I do ```./char_array```, the console prints "Hello, world", as expected. Which means that a string isn't really a string, but a list of char, and the reference is the pointer to the first char, with '/0' being the end of the string. That's the delimiter character.

- The number begins at 0.
- The last character is a /0, __null-byte__.
- The character array was defined, so 20 bytes are allocated for it, but only 12 of these bytes are actually used.

Since setting each character in a character array is painstacking and strings are used often, a set of standard functions was created for string manipulation: ```strcpy()``` will copy a string from a source to a destination. We can rewrite char_array.c using this function:

###### char_array2

```c
#include <stdio.h> #include <string.h>
int main() {
char str_a[20];
strcpy(str_a, "Hello, world!\n");
printf(str_a); }
```

#### Signed, unsigned, long, short

By default, numerical values in C are signed, which means that a bit of information is used to store the sign of the number. Negative numbers are stored different than you might expect: we use **two's complement**.

When a negative value is added to a positive number of the same magnitude, the result will be 0. In binary, that implies going all round back to 0, because binary numbers with fixed length work circulary. Thus, in order to get the negative number, one must invert all the bits of the number in question, then add one.
This can be explored quickly on a smaller scale using pcalc:

```
$ pcalc 0y01001001
  73                0x49                0y01001001
$ pcalc 0y10110110 + 1
  183             	0xb7              	0y10110111
$ pcalc 0y10110111 + 0y01001001
	256             	0x100              0y100000000

The program pcalc shows the value 256 because it’s not aware that we’re only dealing with 8-bit values. Which means, the 9th digit, counting from the right, may be 1, but we have come all the way back to 0 on the first 8.

In C, variables can be declared as unsigned by simply prepending the keyword unsigned to the declaration. In addition, the size of numerical variables can be extended or shortened by adding the keywords long or short.

Let's explore the macro ```sizeof()``` by means of datatype_sizes.c:

```
#include <stdio.h>
int main() {
printf("The 'int' data type is\t\t %d bytes\n", sizeof(int));
printf("The 'unsigned int' data type is\t %d bytes\n", sizeof(unsigned int));
printf("The 'short int' data type is\t %d bytes\n", sizeof(short int));
printf("The 'long int' data type is\t %d bytes\n", sizeof(long int));
printf("The 'long long int' data type is %d bytes\n", sizeof(long long int));
printf("The 'float' data type is\t %d bytes\n", sizeof(float));
printf("The 'char' data type is\t\t %d bytes\n", sizeof(char)); }
```
```

```
$ ./a.out
The 'int' data type is		 4 bytes
The 'unsigned int' data type is	 4 bytes
The 'short int' data type is	 2 bytes
The 'long int' data type is	 8 bytes
The 'long long int' data type is 8 bytes
The 'float' data type is	 4 bytes
The 'char' data type is		 1 bytes
```

#### Pointers
