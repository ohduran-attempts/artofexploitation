initialised# Art of Exploitation

In order to hack away in a tested environment, do the following:

1. Install [Docker](https://itnext.io/docker-101-fundamentals-the-dockerfile-b33b59d0f14b)
2. ```docker build -t exploitation:latest .```
3. ```docker run -it --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -v $PWD:/app exploitation:latest bash```
4. Inside GDB, do ```set disassembly-flavor intel```.

## Main TakeAways

- Hackers get their edge from knowing how all the pieces interact within the bigger picture.

- Thinking of C-source as a program is a common misconception that is exploited by hackers every day. As long as the compiled program works, the average programmer is only concerned with source code. But a hacker realizes that the compiled program is what actually gets executed out in the real world.

- Most hacker exploits are a lot like magic tricks—they seem amazing and magical, unless you know about sleight of hand and misdirection.

- The important thing to remember about variables in C is that the compiler is the only thing that cares about a variable’s type.

## Programming

### firstprog.c & firstprog.txt

The hexadecimal numbers— 100000f40— are memory addresses. Like a row of houses on a local street, memory can be thought of as a row of bytes, each with its own memory address.

The hexadecimal bytes in the middle are the machine language instructions for the processor. The machine code is displayed as bytes and each instruction is put on its own line, like splitting a paragraph into sentences.

The instructions on the far right are in assembly language; a collection of mnemonics for the corresponding machine language instructions. Assembly language instructions have a direct one-to-one relationship with their corresponding machine language instruction; each processor has a different form of assembly language. While you can theoretically create your own x86 assembly language syntax, most people stick with one of the two main types: AT&T syntax and Intel syntax. It’s easy to recognize AT&T syntax by the cacophony of % and $ symbols prefixing everything.

### GDB
Inside Docker: ```docker run -it  --rm -v $(pwd):/app ubuntu:latest bash``` (remember to do apt-get build-essentials gdb to have gdb and gcc)

```gdb -q ./a.out```

#### General purpose registers:

- rax: Accumulator
- rbx: Base
- rcx: Counter
- rdx: Data

Temporary variables for the CPU

#### Pointers and indexes

- rsi: Source Index
- rdi: Destination Index
- rbi: Base Pointer
- rsi: Stack Pointer

Pointers store memory addresses; Indexes point to source and destination where data needs to be read from or written to.

### Instruction Pointer

- rip: Instruction Pointer

Like a child pointing his finger at each word as he reads, the processor reads each instruction using the RIP register as finger.

At first, it points at 0x5648307eb63e. Check out firstprog-Intel-ubuntu: the first memory address is 63a!

Now, what is 63b and 63e doing:

63b:	48 89 e5             	mov    rbp,rsp
63e:	48 83 ec 10          	sub    rsp,0x10

The assembly instructions in Intel syntax generally follow this style: operation <destination>, <source>. Mov will move a value from the source to destination, sub will subtract, inc will increment, etc.

- gdb break main ... run ... info registers rip

First, the breakpoint is set at the start of main(), and the program is run. Since the breakpoint has been set at the start of main, the program hits the breakpoint and pauses before actually executing any instructions in main.

notice that ```info register rip``` points to an instruction in the main() function's disassembly (the fourth, to be precise). The instruction before this are collectively known as the *function prologue* and aer generated to set up memory for the rest of the main function local variables. In fact, we declare. variables in C in order to aid the construction of this prologue.

The debugger knows this, and skips over this part.

- Examine memory using ```x```

The default size of a single unit is a four byte unit called a *word*. This is confusing because sometimes it also refers to a 2 byte value, and thus a DWORD, or double word refers to a 4-byte value. We'll use word and DWORD interchangeably.

b - single byte
h - halfword, two bytes
w - word, four bytes
g - giant, eight bytes

And the format:

o - octal
x - hexadecimal
u - unsigned, standard decimal
t - binary

A number can also be prepended to the format of the examine command to examine multiple units at the target address.

You can try ```x/8xb $rip```. This is what you may get:

(gdb) x/8xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00	0xeb

(gdb) x/8xh $rip

0x563dfc6f1642 <main+8>:	0x45c7	0x00fc	0x0000	0xeb00	0x4810	0x3d8d	0x00a2	0x0000

(gdb) x/8xw $rip

0x563dfc6f1642 <main+8>:	0x00fc45c7	0xeb000000	0x3d8d4810	0x000000a2

0x563dfc6f1652 <main+24>:	0xfffeb9e8	0xfc4583ff	0xfc7d8301	0xb8ea7e09


Now, you may have noticed that those commands that use bigger units display more data. However, x/8xb showed the first two bytes to be 0xc7 and 0x45, __but__ x/8xh showed that memory address to be 0x45c7, and x/8xw also shows 0x00fc45c7, which keeps reversing the two memory addresses showed in x/8xh.

In the x86 processor, values are stored in *little-endian* byte order, which means that the least significant byte is stored first. GDB is simply smart enough to know how values are stored, so when a word or halfword is examined, the bytes must be reversed.

Revisiting these values displayed both as hexadecimal and unsigned decimals might help clear up any confusion.

(gdb) x/4xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00

(gdb) x/4ub $rip

0x563dfc6f1642 <main+8>:	199	69	252	0

(gdb) x/1uw $rip

0x563dfc6f1642 <main+8>:	16532935

Notice this: 199 * (256^3) + 69 * (256^2) + 252 * (256^1) + 0 = 3343252480 WRONG!

But: 0 * (256^3) + 252 * (256^2) + 69 * (256^1) + 199 = 16532935 RIGHT!


GDB can also disassemble machine language into assembly instructions, with the command ```i```:

(gdb) x/i $rip

=> 0x563dfc6f1642 <main+8>:	movl   $0x0,-0x4(%rbp)

(gdb) x/3i $rip

=> 0x563dfc6f1642 <main+8>:	movl   $0x0,-0x4(%rbp)
   0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>
   0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4

Since the RIP register points to memory that contains machine language instructions, they disassemble nicely, and matches what we did with ```objdump``` (check out lines 4 to 6 in firstprog-ATT-ubuntu).

The first instruction will move the value of 0x0 (0, obviously) into memory located at the address stored in the RBP register, minus 0x4 (4, ditto). That's where the C variable ```i``` is stored! And the 4 is exactly the size of an integer on the x86 processor! It follows that this command will zero out the variable i for the for loop.

The memory at this location can be examined in several ways:

(gdb) i r $rbp

rbp            0x7ffe3e65d3d0	0x7ffe3e65d3d0

(gdb) x/4xb $rbp - 4

0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(gdb) x/4xb $rbp - 4
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

Oh, wow. The book was expecting random garbage, but I can see that the variable is initialised as 0. Looking at this [question from SO](https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value), it doesn't make any sense.

Ah, wait. I did initialised the variable, ```for (i=0....)```! My Mac is probably misbehaving, or I'm using a version of C that outdated this book.

Now, if $rbp ends in d0, then 4 bytes before in terms of address is cc (-1byte is cf, -2 is ce, -3 is cd, then -4 is cc). So the address showed is correct and in fact:

(gdb) x/4b 0x7ffe3e65d3cc
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(gdb) print $rbp -4
$1 = (void *) 0x7ffe3e65d3cc


(gdb) x/4b $1
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

print also allows us to both print a particular value in a certain address and store that address on a variable.


---

Let's execute the current instruction using the command ```nexti```. The processor will read RIP, execute it, and advance RIP to the next instruction address.

(gdb) nexti
0x0000563dfc6f1649	6	    for(i=0; i < 10; i++){

(gdb) x/4xb $1
0x7ffe3e65d3cc:	0x00	0x00	0x00	0x00

(Now it displays 0, again!)

(gdb) i r $rip
rip            0x563dfc6f1649	0x563dfc6f1649 <main+15>

(gdb) x/i $rip
=> 0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>

i = 0, and RIP goes to the next instruction:

(gdb) x/10i $rip
=> 0x563dfc6f1649 <main+15>:	jmp    0x563dfc6f165b <main+33>
   0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4
   0x563dfc6f1652 <main+24>:	callq  0x563dfc6f1510 <puts@plt>
   0x563dfc6f1657 <main+29>:	addl   $0x1,-0x4(%rbp)
   0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)
   0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>
   0x563dfc6f1661 <main+39>:	mov    $0x0,%eax
   0x563dfc6f1666 <main+44>:	leaveq
   0x563dfc6f1667 <main+45>:	retq   
   0x563dfc6f1668:	nopl   0x0(%rax,%rax,1)

First, jump to 65b. That's easy: it's the instruction below, the one that says ```cmp```. It's a compare instruction, number 0x9 with what's stored in $rbp - 0x04.
The next is ```jle```, jump if less or equal, which combined with the previous means that if variable i is less or equal than 9, then jump tp 64b. Since we know that i is now 0, we are going to be directed to that 64b. At least for now.

(gdb) nexti

0x0000563dfc6f165b	6	    for(i=0; i < 10; i++){

(gdb) x/i $rip

=> 0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)

(gdb) x/i $rip

=> 0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>

Now, next instruction:

(gdb) nexti

7	        puts("Hello, world\n");

(gdb) i r $rip

rip            0x563dfc6f164b	0x563dfc6f164b <main+17>

(gdb) x/2i $rip
=> 0x563dfc6f164b <main+17>:	lea    0xa2(%rip),%rdi        # 0x563dfc6f16f4

   0x563dfc6f1652 <main+24>:	callq  0x563dfc6f1510 <puts@plt>

So yes, 64b, and the instruction ```lea```. That's Load Effective Address, which means that the value in RIP + 0xa2 is moved onto $RDI. It's like a mov, but with memory addresses (the old book keeps the mov, it's perhaps the version of the compiler.

But what's so special about storing $RIP + 0xa2 into $RDI?? What is RDI pointing at?

(gdb) x/6xb $rdi

0x563dfc6f16f4:	0x48	0x65	0x6c	0x6c	0x6f	0x2c

(gdb) x/6cb $rdi

0x563dfc6f16f4:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	44 ','

(gdb) x/s $rdi

0x563dfc6f16f4:	"Hello, world\n"

Neat! It stores the string "Hello world"!

Remember, in the AoE book:

- ESP = RDI

- EIP = RIP

So if I do ```n``` (for next):

(gdb) n  
Hello, world

6	    for(i=0; i < 10; i++){

Bum! It prints the string!

What are the next three instructions?

(gdb) x/2i $rip
=> 0x563dfc6f1657 <main+29>:	addl   $0x1,-0x4(%rbp)

   0x563dfc6f165b <main+33>:	cmpl   $0x9,-0x4(%rbp)

   0x563dfc6f165f <main+37>:	jle    0x563dfc6f164b <main+17>

One means add 1 into what's stored in $RBP -4 (variable i, remember?). The second one compares, once again, the variable i and 9. And the third acts upon that comparison: again, if i is less than or equal to 9, go to 64b, and start again. That's the for loop, in action.

That's "hello, world." -- drop mic.

### Back to basics

#### Strings

Did you noticed? $rdi, in line 7, points to 0x563dfc6f16f4, which stored the value 0x48. That's when we did ```x/6cb``` and realised that the next 6 bytes referred to H, e, l, l, o, and so on. The variable wasn't a string: it was a pointer to the first letter. When calling callq on [puts](http://www.cplusplus.com/reference/cstdio/puts/), "The function begins copying from the address specified (str) until it reaches the terminating null character ('\0'). This terminating null-character is not copied to the stream."

I'm not in a position to actually look inside but we're close enough to the machine already.

In order to see it, we'll run char_array.c with the debugger:


```
#include <stdio.h>
int main()
{
char str_a[20];
 str_a[0] = 'H';
 str_a[1] = 'e';
 str_a[2] = 'l';
 str_a[3] = 'l';
 str_a[4] = 'o';
 str_a[5] = ',';
 str_a[6] = ' ';
 str_a[7] = 'w';
 str_a[8] = 'o';
 str_a[9] = 'r';
 str_a[10] = 'l';
 str_a[11] = 'd';
 str_a[12] = '!';
 str_a[13] = '\n';
 str_a[14] = 0;
 printf(str_a);
}
```


The first thing to be noticed is the warning when compiling it:

warning: format string
      is not a string literal (potentially
      insecure) [-Wformat-security]

The debugger is noticing something weird: it's not a string, but a list. However, it's not stopping the compiler from doing its job, so let's push it.


When I do ```./char_array```, the console prints "Hello, world", as expected. Which means that a string isn't really a string, but a list of char, and the reference is the pointer to the first char, with '/0' being the end of the string. That's the delimiter character.

- The number begins at 0.
- The last character is a /0, __null-byte__.
- The character array was defined, so 20 bytes are allocated for it, but only 12 of these bytes are actually used.

Since setting each character in a character array is painstacking and strings are used often, a set of standard functions was created for string manipulation: ```strcpy()``` will copy a string from a source to a destination. We can rewrite char_array.c using this function:

###### char_array2

```c
#include <stdio.h> #include <string.h>
int main() {
char str_a[20];
strcpy(str_a, "Hello, world!\n");
printf(str_a); }
```

#### Signed, unsigned, long, short

By default, numerical values in C are signed, which means that a bit of information is used to store the sign of the number. Negative numbers are stored different than you might expect: we use **two's complement**.

When a negative value is added to a positive number of the same magnitude, the result will be 0. In binary, that implies going all round back to 0, because binary numbers with fixed length work circulary. Thus, in order to get the negative number, one must invert all the bits of the number in question, then add one.
This can be explored quickly on a smaller scale using pcalc:

```
$ pcalc 0y01001001
  73                0x49                0y01001001
$ pcalc 0y10110110 + 1
  183             	0xb7              	0y10110111
$ pcalc 0y10110111 + 0y01001001
	256             	0x100              0y100000000

The program pcalc shows the value 256 because it’s not aware that we’re only dealing with 8-bit values. Which means, the 9th digit, counting from the right, may be 1, but we have come all the way back to 0 on the first 8.

In C, variables can be declared as unsigned by simply prepending the keyword unsigned to the declaration. In addition, the size of numerical variables can be extended or shortened by adding the keywords long or short.

Let's explore the macro ```sizeof()``` by means of datatype_sizes.c:

```
#include <stdio.h>
int main() {
printf("The 'int' data type is\t\t %d bytes\n", sizeof(int));
printf("The 'unsigned int' data type is\t %d bytes\n", sizeof(unsigned int));
printf("The 'short int' data type is\t %d bytes\n", sizeof(short int));
printf("The 'long int' data type is\t %d bytes\n", sizeof(long int));
printf("The 'long long int' data type is %d bytes\n", sizeof(long long int));
printf("The 'float' data type is\t %d bytes\n", sizeof(float));
printf("The 'char' data type is\t\t %d bytes\n", sizeof(char)); }
```
```

```
$ ./a.out
The 'int' data type is		 4 bytes
The 'unsigned int' data type is	 4 bytes
The 'short int' data type is	 2 bytes
The 'long int' data type is	 8 bytes
The 'long long int' data type is 8 bytes
The 'float' data type is	 4 bytes
The 'char' data type is		 1 bytes
```

#### Pointers
The RIP register is a pointer that points to the current instruction during a program's execution by containing its memory address. The idea of pointers is also used in C: they can be used like any other variable, prepending an asterisk to the variable name.

In pointers.c, we print "Hello, world", then print from the third character onwards "llo, world", and then we substitute that last part with "y you guys!" so that, when printing again the initial variable, it shows "Hey you guys".

Let's take a look at it with gdb. When the pointer is examined as a string, it's apparent that the given string is there, located at memory address 0x7fffffffe630 (using ```x/xw pointer```), and value "Hello, world\n" (using ```x/s pointer```). In order to use the value that the pointer __points to__, you must use the *unary operator*, &, prepended to a variable name.

(gdb) x/xw &pointer

0x7fffffffe620:	0xffffe630

(gdb) print &pointer

$1 = (char \*\*) 0x7fffffffe620

(gdb) print pointer
$2 = 0x7fffffffe630 "Hello, world\n"

When the address-of operator is used, the pointer variable is shown to be located at the address 0x7fffffffe620 in memory, and it contains the address 0xffffe630.

The address-of operator is often used in conjunction with pointers, since pointers contain memory addresses, like in addressof.c:

´´´c
#include <stdio.h>
int main() {
int int_var = 5; int \*int_ptr;
int_ptr = &int_var; // put the address of int_var into int_ptr
}
´´´

Using gdb:

(gdb) print &int_var

$2 = (int \*) 0x7fffffffe63c

(gdb) print int_ptr
$3 = (int \*) 0x7fffffffe63c

An additional unary operator called the dereference operator exists for use with pointers: \*.

(gdb) print \*int_ptr

$4 = 5

When the unary operators are used with pointers, the address-of oper- ator can be thought of as moving backward, while the dereference operator moves forward in the direction the pointer is pointing.


#### Format Strings

A format string is just a character string with special escape sequences that tell the function to insert variables printed in a specific format in palce of the scape sequence.

The way the printf() function has been used in the previous programmes, "Hello, world\n" string, technically is the format string, but without special scape sequences.

These escape sequences are called *format parameters*, and for each one the function is expected to take an additional argument:

%d - decimal
%u - unsigned decimal
%x - hexadecimal
%f - floating-point variable
%s - string
%n - number of bytes written so far


The %s expects a memory address. Let's put everything in context with fmt_strings.c

```
#include <stdio.h>

int main(){
  char string[10];
  int A = -73;
  unsigned int B = 31337;

  strcpy(string, "sample");

  // Example of printing with different format strings:
  printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);
  printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);
  printf("[field width on B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);
  printf("[string] %s Address %08x\n", string, string);

  // Example of unary address operator (dereferencing) and a %x format string
  printf("variable A is at address: %08x\n", &A);
}
```

./fmt_strings
[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
[field width on B] 3: '31337', 10: '     31337', '00031337'
[string] sample Address 5c7edd8e
variable A is at address: 5c7edd84


The third line in the example, labeled [field width on B], shows the use of the field-width option in a format parameter. This is just an integer that designates the minimum field width for that format parameter. However, this is not a maximum field width—if the value to be outputted is greater than the field width, the field width will be exceeded.

This happens when 3 is used, since the output data needs 5 bytes. When 10 is used as the field width, 5 bytes of blank space are outputted before the output data. Additionally, if a field width value begins with a 0, this means the field should be padded with zeros. When 08 is used, for example, the output is 00031337.

Format strings are used by an entire family of standard I/O functions, including scanf(), which basically works like printf() but for input. One key difference is that scanf() expects all of its arguments to be pointers, os the arguments must actually be variable addresses— not the variables themselves.

#### Typecasting

Typecasting is a simple way to temporarily change a variable's data type, despite how it was originally defined. When a variable is typecast into a different type, the compiler is told to treat that variable as if it were the new data type, but only for that operation.

Have you ever used integers and floating point variables altogether?

Let's see typecasting.c

```
#include <stdio.h>

int main(){
  int a, b;
  float c, d;

  a = 13;
  b = 5;

  c = a / b;
  d = (float) a / (float) b;

  printf("[integers]\t a = %d\t b = %d\n", a, b);
  printf("[floats]\t c = %f\t d = %f\n", c, d);
}
```

[integers]	 a = 13	 b = 5
[floats]	 c = 2.000000	 d = 2.600000

dividing integers will round down to the incorrect answer 2, even if the value is stored as a floating-point variable; you must divide floating points to get a float, which will allow for the correct calculation.

This example is illustrative, but where typecasting shines is when it is used with pointer variables.

Even though a pointer is just a memory address, C demands a data type for every pointer (it's trying to limit programming errors, which makes sense, but it's annoying). An integer pointer should only point to integer data, while a character pointer should only point to character data, and so on. Another reason is for pointer arithmetic. An integer is four bytes in size, while a character only takes up a single byte: when I do int_pointer + 1, the amount of bytes being added to the pointer is different than when I do char_pointer + 1.

Let's illustrate this with pointer_types.c:

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  char *char_pointer;
  int *int_pointer;

  char_pointer = char_array;
  int_pointer = int_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the integer %d\n", int_pointer, *int_pointer);
    int_pointer = int_pointer + 1;
  }

  for (i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the char %c\n", char_pointer, *char_pointer);
    char_pointer = char_pointer + 1;
  }
}
```

[integer pointer] points to 0x7ffd0f1cf510, which contains the integer 1
[integer pointer] points to 0x7ffd0f1cf514, which contains the integer 2
[integer pointer] points to 0x7ffd0f1cf518, which contains the integer 3
[integer pointer] points to 0x7ffd0f1cf51c, which contains the integer 4
[integer pointer] points to 0x7ffd0f1cf520, which contains the integer 5
[char pointer] points to 0x7ffd0f1cf533, which contains the char a
[char pointer] points to 0x7ffd0f1cf534, which contains the char b
[char pointer] points to 0x7ffd0f1cf535, which contains the char c
[char pointer] points to 0x7ffd0f1cf536, which contains the char d
[char pointer] points to 0x7ffd0f1cf537, which contains the char e

Check that out! The int_pointer moves in 4-byte steps, whereas char_pointer moves in 1-byte step, even though the same value of 1 is added to int_pointer and char_pointer in their respective loops.

What if I swap them?

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  char *char_pointer;
  int *int_pointer;


  // SWAP
  char_pointer = int_array;
  int_pointer = char_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the char %c\n", int_pointer, *int_pointer);
    int_pointer = int_pointer + 1;
  }

  for (i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the int %d\n", char_pointer, *char_pointer);
    char_pointer = char_pointer + 1;
  }
}
```

When compiling, I get the following warning: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types]


[integer pointer] points to 0x7ffcce291323, which contains the char a
[integer pointer] points to 0x7ffcce291327, which contains the char e
[integer pointer] points to 0x7ffcce29132b, which contains the char @
[integer pointer] points to 0x7ffcce29132f, which contains the char
[integer pointer] points to 0x7ffcce291333, which contains the char ?
[char pointer] points to 0x7ffcce291300, which contains the int 1
[char pointer] points to 0x7ffcce291301, which contains the int 0
[char pointer] points to 0x7ffcce291302, which contains the int 0
[char pointer] points to 0x7ffcce291303, which contains the int 0
[char pointer] points to 0x7ffcce291304, which contains the int 2

Even though int_pointer points to char data, it is still typed as an integer: adding 1 to it will increment the address by 4 each time, and you go from 'a' to 'e' on the very first step. Similarly, char_pointer address is only incremented by 1 each time, so it takes 4 steps to go from 1 to 2, going through all the little-endian representation of 1: 0x01, 0x00, 0x00, 0x00.

To fix this, we may use typecasting:

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  char *char_pointer;
  int *int_pointer;

  char_pointer = int_array;
  int_pointer = char_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the char %c\n", int_pointer, *int_pointer);
    int_pointer = (int *) ((char *) int_pointer + 1);
  }

  for (i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the int %d\n", char_pointer, *char_pointer);
    char_pointer = (char *) ((int *) char_pointer + 1);
  }
}
```

For int_pointer, I cast it as char pointer before adding 1, and then recast it as int. For char_pointer, I cast it as int before adding 1, and then recast it as char.

[integer pointer] points to 0x7ffe988e8e33, which contains the char a
[integer pointer] points to 0x7ffe988e8e34, which contains the char b
[integer pointer] points to 0x7ffe988e8e35, which contains the char c
[integer pointer] points to 0x7ffe988e8e36, which contains the char d
[integer pointer] points to 0x7ffe988e8e37, which contains the char e
[char pointer] points to 0x7ffe988e8e10, which contains the int 1
[char pointer] points to 0x7ffe988e8e14, which contains the int 2
[char pointer] points to 0x7ffe988e8e18, which contains the int 3
[char pointer] points to 0x7ffe988e8e1c, which contains the int 4
[char pointer] points to 0x7ffe988e8e20, which contains the int 5

Naturally, it's way easier to just use the correct data types in the first place; sometimes a generic pointer is desired, like the void pointer.

We can modify pointer_types3.c to use a single pointer by typecasting it to the proper type each time it's used:

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  void *void_pointer;

  void_pointer (void *) char_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the char %c\n", void_pointer, *((char *) void_pointer));
    void_pointer = (void *)((char*) void_pointer + 1);
  }

  void_pointer = (void *) int_array;

  for i(i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the int %d\n", void_pointer, *((int *) void_pointer));
    void_pointer = (void *)((int *) void_pointer + 1);
  }
}
```

All of this results in the same outcome. The void pointer is really just holding memory addresses, while the hard-coded typecasting is responsible to give meaning to that + 1 on the iteration.

But we can also use anything that can store a 4-byte value as memory. How about an unsigned integer?

```
#include <stdio.h>

int main(){
  int i;

  char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
  int int_array[5] = {1, 2, 3, 4, 5};

  unsigned int hacky_nonpointer;

  hacky_nonpointer = (unsigned int) char_array;

  for (i = 0; i<5; i++){
    printf("[integer pointer] points to %p, which contains the char %c\n", unsigned_int, *((char *) unsigned_int));
    hacky_nonpointer = hacky_nonpointer + sizeof(char);
  }

  hacky_nonpointer = (unsigned int) int_array;


  for (i = 0; i<5; i++){
    printf("[char pointer] points to %p, which contains the int %d\n", unsigned_int, *((int *) unsigned_int));
    hacky_nonpointer = hacky_nonpointer + sizeof(int);
  }
}
```

All of this is very hacky, but the typecasting enables us with the power to extend what we're capable of doing with unsigned ints.

#### Command-Line Arguments

Many non-graphical programs receive input in the form of command-line arguments. They don't require user interaction after execution has begun: it's more efficient.

In C, command-line arguments can be accessed in the main() function by including two additional arguments to the function: an integer and a pointer to an array of strings.

Like this:

```
#include <stdio.h>

int main(int arg_count, char *arg_list[]){
  int i;
  printf("There were %d arguments provided:\n", arg_count);
  for (i=0; i<arg_count; i++){
    printf("argument #%d\t-\t%s\n", i, arg_list[i]);
  }
}
```
The zeroth argument is always the name of the executing binary, and the rest of the argument array (often called an argument vector) contains the remaining arguments as strings.

```sh
./commandline this is a test
There were 5 arguments provided:
argument #0	-	./commandline
argument #1	-	this
argument #2	-	is
argument #3	-	a
argument #4	-	test
```

Given that the arguments are always strings, one may want to convert it into an integer to manipulate results. In order to do so we can use atoi(), as in ASCII to integer:

```c
#include <stdio.h>
#include <stdlib.h>

void usage(char *program_name){
  printf("Usage %s <message> <# of times to repeat>\n", program_name);
  exit(1);
}


int main(int argc, char *argv[]){
  int i, count;

  if (argc <3){
    usage(argv[0]); // If there are fewer than 3 arguments, exit!
  };

  count = atoi(argv[2]);
  printf("Repeating %d times...\n", count);

  for (i=0; i < count; i++){
    printf("%3d - %s\n", i, argv[1]); // print the first argument
  }
}
```
```sh
root@hacker:/app# ./a.out
Usage ./a.out <message> <# of times to repeat>
root@hacker:/app# ./a.out "Hello!" 3
Repeating 3 times...
  0 - Hello!
  1 - Hello!
  2 - Hello!
```

Notice that we must consider the possibility that the argument count is less than 3, given that we are accessing argv[1]. If we trieed to continue with the operations without providing at least 3 arguments, the program would try to access a part of memory that's outside the program's scope. In C it’s important to check for these types of conditions and handle them in program logic.

If we comment that if statement, we'll see what happens:

```sh
root@5cf102276c99:/app# gcc convert2.c
root@5cf102276c99:/app# ./a.out "Hello!" 3
Repeating 3 times...
  0 - Hello!
  1 - Hello!
  2 - Hello!
root@5cf102276c99:/app# ./a.out
Repeating 0 times...
root@5cf102276c99:/app# ./a.out test
Segmentation fault
```

Segmentation fault is precisely that: the program is trying to access memory that isn't allowed to. Memory is split into segments (which will be discussed later), and some memory addresses aren’t within the boundaries of the memory segments the program is given access to. When the program attempts to access an address that is out of bounds, it will crash and die in what’s called a segmentation fault. This effect can be explored further with GDB:

```
(gdb) run test
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /app/a.out test

Breakpoint 1, 0x00005555555546fc in main ()
(gdb) x/3xw 0x00005555555546fc
0x5555555546fc <main+4>:	0x20ec8348	0x48ec7d89	0x48e07589
(gdb) x/s 0x20ec8348
0x20ec8348:	<error: Cannot access memory at address 0x20ec8348>
(gdb) x/s 0x48ec7d89
0x48ec7d89:	<error: Cannot access memory at address 0x48ec7d89>
(gdb) x/s 0x48e07589
0x48e07589:	<error: Cannot access memory at address 0x48e07589>
(gdb) c   
Continuing.

Program received signal SIGSEGV, Segmentation fault.
__GI_____strtol_l_internal (nptr=0x0, endptr=endptr@entry=0x0,
    base=base@entry=10, group=group@entry=0,
    loc=0x7ffff7dd0560 <_nl_global_locale>) at ../stdlib/strtol_l.c:292
292	../stdlib/strtol_l.c: No such file or directory.
```

Since the argument vector is a pointer to list of strings, it is actually a pointer to a list of pointers. Using the command x/3xw to examine the first three memory addresses stored at the argument vector’s address shows that they are themselves pointers to strings. When the program tries to access this memory addresses, it crashes with a segmentation fault.

#### Variable scoping

Another interesting concept regarding memory in C is variable scoping or context—in particular, the contexts of variables within functions. Each function has its own set of variables, even if it's the same function being called a bit later. Let's check it out:

```
#include <stdio.h>

void func3(){
  int i = 11;
  printf("\t\t\t[in func3] i = %d\n", i);
};

void func2(){
  int i = 7;
  printf("\t\t[in func2] i = %d\n", i);
  func3();
  printf("\t\t[back in func2] i = %d\n", i);
};

void func1(){
  int i = 5;
  printf("\t[in func1] i = %d\n", i);
  func2();
  printf("\t[back in func1] i = %d\n", i);
};

int main(){
  int i = 3;
  printf("[in main] i = %d\n", i);
  func1();
  printf("[back in main] i = %d\n", i);
};

```

When compiling and executing, this is what we get:

[in main] i = 3
	[in func1] i = 5
		[in func2] i = 7
			[in func3] i = 11
		[back in func2] i = 7
	[back in func1] i = 5
[back in main] i = 3

i takes different value depending on the context in which we call the function. Even if they're all called i, they aren't the same variable. They aren't __global__; although they could be.

Let's set j outside func1, func2, and func3, but *also* setting j inside func2, like we did in scope2, to see:

```
[in main] i = 3, j = 42
	[in func1] i = 5, j = 42
		[in func2] i = 7, j = 42
		[in func2] setting j = 1337
			[in func3] i = 11, j = 999
		[back in func2] i = 7, j = 1337
	[back in func1] i = 5, j = 1337
[back in main] i = 3, j = 1337
```

In the output, the global variable j is written to in func2(), and the change persists in all functions except func3() , which has its own local variable called j. The compiler makes the local variable take precedence over the global one.

With all these variables using the same names, it can be a little confusing, but remember that in the end, it’s all just memory. The local variables for each function are each stored in their own places in memory, regardless of the identical names.

Let's print the memory addresses to make this explicit.

```
[in main] i @ 0xaefcd384 = 3
[in main] j @ 0xfc058010 = 42
	[in func1] i @ 0xaefcd364 = 5
	[in func1] j @ 0xfc058010 = 42
		[in func2] i @ 0xaefcd344 = 7
		[in func2] j @ 0xfc058010 = 42
		[in func2] setting j = 1337
			[in func3] i @ 0xaefcd320 = 11
			[in func3] j @ 0xaefcd324 = 999
		[back in func2] i @ 0xaefcd344 = 7
		[back in func2] j @ 0xfc058010 = 1337
	[back in func1] i @ 0xaefcd364 = 5
	[back in func1] j @ 0xfc058010 = 1337
[in main] j @ 0xfc058010 = 1337
[back in main] j @ 0xfc058010 = 1337
```

i is stored, at the same time, in 0xaefcd384, 0xaefcd364, 0xaefcd344 and 0xaefcd320. j is stored in 0xfc058010 all the time, except in func3, where it's stored in 0xaefcd324. That makes perfect sense; the compiler is reserving memory for each local variable on the stack, *regardless of their name*. Only a global variable would reuse the memory address because it's the same variable all along.

Each time a function is called, a record called a stack frame is put on the stack. They are, for all use and purposes, completely different functions in terms of memory.

In addition to globals, variables can also be defined as **static** variables by prepending the keyword static to the variable definition. Similar to global variables, a static variable remains intact between function calls; however, static variables are also akin to local variables since they remain local within a particular function context. One different and unique feature of static variables is that they are only initialized once. The code in static.c will help explain these concepts.

Let's see static in action:

```
#include <stdio.h>

void function(){
  int var = 5;
  static int static_var = 5; // Static variable initialisation

  printf("\t[in function] var = %d\n", var);
  printf("\t[in function] static_var = %d\n", static_var);
  var++; // Add one to var.
  static_var++; // Add one to static_var.
}

int main(){
  int i;
  static int static_var = 1337; // Another static, in a different context

  for(i=0; i<5; i++){
    printf("[in main] static_var = %d\n", static_var);
    function(); // Call the function.
  }
}
```

What we are trying to do is see what happens when we initialise static and non static variables outside the context in which they were created.


```
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 5
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 6
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 7
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 8
[in main] static_var = 1337
	[in function] var = 5
	[in function] static_var = 9
```

The aptly named static_var is defined as a static variable in two places: within the context of main() and within the context of function(). Since static variables are local within a particular functional context, these variables can have the same name, but they actually represent two different locations in memory. Notice that **the static_var retains its value between subsequent calls to function()**: static variables are only initialised once, being local to a particular function context.

[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 5
[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 6
[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 7
[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 8
[in main] static_var @ 0x804968c = 1337
  [in function] var @ 0xbffff814 = 5
  [in function] static_var @ 0x8049688 = 9

In memory, of course, the variable static_var is placed in two memory addresses along the way: one for the main context, 0x804968c, and the second one for the function context, 0x8049688.

### Memory Segmentation

A compiled program’s memory is divided into five segments:

- text
- data
- bss
- heap
- stack

Each segment represents a special portion of memory that is set aside for a certain purpose.

The __text segment__, or code segment, is where the assembled machine language instructions of the program are located. The execution of instructions in this segment is nonlinear, thanks to the high-level control structures (if, for, while, and so on) that eventually compile into branch, jump, and call instructions in assembly language.

As a program executes, the RIP is set to the first instruction in the text segment. The processor then follows an execution loop that does the following:

1. Reads the instruction that EIP is pointing to.
2. Adds the byte length of the instruction to RIP.
3. Executes the instruction that was read in step 1.
4. Goes back to step 1.

Write permission is disabled in the text segment, as it is not used to store variables, only code. This *prevents people from actually modifying the program code*; any attempt to write to this segment of memory will kill the program. Another advantage of this segment being read-only is that it *can be shared among different copies of the program*, allowing multiple executions of the program at the same time without any problems.

The data and bss segments are used to store global and static programme variables. The __data segment__ is filled with the initialised global and static variables, while the __bss segment__ is filled with their uninitialised counterparts. They are writable, but have fixed size: global variables are, thus, persistent, and they do persist because they are stored here.

The __heap segment__ is a segment that the programmer can directly control. Blocks can be allocated for whatever he or she needs to. It can grow larger or smaller as needed, and all of it is managed by the allocator and deallocator algorithms: a programmer using the heap can reserve and free memory on the fly. The growth of the heap moves downward toward higher memory addresses.

The __stack segment__ also has variable size and is used as a temporary scratch pad to store local function variables and context during function calls. This is where GDB backtrace looks at. Each function's context, its own set of variables and the RIP address and where it should go after the function has completed, is stored together on the stack in what is called *stack frame*. As the name implies, the stack segment of memory is a stack data structure, which piles up stack frames on top of each other. The RSP register is used to keep track of the address of the end of the stack, which is constantly changing as items are pushed into and popped off of it. It grows upward in a visual listing of memory, toward lower memory addresses.

The stack is First In Last Out; it makes sense because it's used to store context, which piles up like the code goes from left to right. When a function is called, the RBP register is used to reference local function variables in the current stack frame. Each frame contains the parameters, its local variables, and two pointers: the saved frame, or SFP, which stores the previous RBP, and the return address, which restores RIP to the next instruction found after the function call.

Let's see this with an example:

```c
void test_function(int a, int b, int c, int d){
  int flag;
  char buffer[10];

  flag = 31337;
  buffer[0] = 'A';
}

int main(){
  test_function(1,2,3,4);
}
```

The memory for the test_function variables is in the stack segment, while the machine instructions for the function's code is in the text segment. Let's see this with GDB.

```
(gdb) disass main
Dump of assembler code for function main:
   0x00000000000006af <+0>:	push   rbp
   0x00000000000006b0 <+1>:	mov    rbp,rsp
   0x00000000000006b3 <+4>:	mov    ecx,0x4
   0x00000000000006b8 <+9>:	mov    edx,0x3
   0x00000000000006bd <+14>:	mov    esi,0x2
   0x00000000000006c2 <+19>:	mov    edi,0x1
   0x00000000000006c7 <+24>:	call   0x66a <test_function>
   0x00000000000006cc <+29>:	mov    eax,0x0
   0x00000000000006d1 <+34>:	pop    rbp
   0x00000000000006d2 <+35>:	ret    
End of assembler dump.
(gdb) disass test_function
Dump of assembler code for function test_function:
   0x000000000000066a <+0>:	push   rbp
   0x000000000000066b <+1>:	mov    rbp,rsp
   0x000000000000066e <+4>:	sub    rsp,0x30
   0x0000000000000672 <+8>:	mov    DWORD PTR [rbp-0x24],edi
   0x0000000000000675 <+11>:	mov    DWORD PTR [rbp-0x28],esi
   0x0000000000000678 <+14>:	mov    DWORD PTR [rbp-0x2c],edx
   0x000000000000067b <+17>:	mov    DWORD PTR [rbp-0x30],ecx
   0x000000000000067e <+20>:	mov    rax,QWORD PTR fs:0x28
   0x0000000000000687 <+29>:	mov    QWORD PTR [rbp-0x8],rax
   0x000000000000068b <+33>:	xor    eax,eax
   0x000000000000068d <+35>:	mov    DWORD PTR [rbp-0x18],0x7a69
   0x0000000000000694 <+42>:	mov    BYTE PTR [rbp-0x12],0x41
   0x0000000000000698 <+46>:	nop
   0x0000000000000699 <+47>:	mov    rax,QWORD PTR [rbp-0x8]
   0x000000000000069d <+51>:	xor    rax,QWORD PTR fs:0x28
   0x00000000000006a6 <+60>:	je     0x6ad <test_function+67>
   0x00000000000006a8 <+62>:	call   0x540 <__stack_chk_fail@plt>
   0x00000000000006ad <+67>:	leave  
   0x00000000000006ae <+68>:	ret    
End of assembler dump.
```

main() starts at 0x00000000000006af and test_function starts at 0x000000000000066a. The first few functions (up to main+1 and test_function+4) set up the stack frame, and are called *procedure prologue*, and they're there to save the frame pointer on the stack, while saving stack memory for the local function variables.

When the test_function is called, the various values are pushed to the stack to create the start of the stack frame as follows: the function arguments are pushed onto the stack in reverse order, so in this case it will push 4, then 3, then 2, then 1. Did you see main+4 all the way through main+19? It's assigning values to ECX, EDX, ESI, EDI, which will store the values that the next instruction, call test_function, will need.

Next, when the assembly call instruction is executed, the return address is pushed onto the stack, and the execution flow jumps to the start of the test_function, at 0x66a. The return value will be the location of the instruction, following the current RIP.

The call instruction both stores the return address on the stack and jumps RIP to the beginning of test_function, so test_function's procedure prologue instructions finish building the stack frame. In this step, the current value of RBP is pushed to the stack (see 66a): this value is called the saved frame pointer (SFP), and it's later used to restore RBP when we leave.

The current value of RSP is then copied to RBP (see 66b) to set the new frame pointer. This frame pointer is used to reference the local variables of the function, flag and bugger. Memory is saved for these variables by substracting from RSP (see 66e, where 0x30 is substracted. 0x30 is 16*3 = 48 bytes. 40 bytes for the 10 char string, + 8 bytes for the int. Everything seems to make sense).

In the end, the stack frame looks something like this:

| Top of the Stack        |
|:-------------:|
| buffer     |
| flag      |
| saved frame pointer (SFP) |
| return address (and above, the frame pointer RBP)   |
|a   |
|b   |
|c   |
|d   |
|...   |

We can watch the stack frame construction on the stack using GDB:

(gdb) list main
4
5	  flag = 31337;
6	  buffer[0] = 'A';
7	}
8
9	int main(){
10	  test_function(1,2,3,4);
11	}

(gdb) break 10
Breakpoint 1 at 0x6b3: file stack_example.c, line 10.
(gdb) break test_function
Breakpoint 2 at 0x67e: file stack_example.c, line 1.
(gdb) run
Starting program: /app/a.out
Breakpoint 1, main () at stack_example.c:10
10	  test_function(1,2,3,4);

(gdb) i r rsp rbp rip
rsp            0x7fffffffe650	0x7fffffffe650
rbp            0x7fffffffe650	0x7fffffffe650
rip            0x5555555546b3	0x5555555546b3 <main+4>

(gdb) x/5i $rip
=> 0x5555555546b3 <main+4>:	mov    $0x4,%ecx
   0x5555555546b8 <main+9>:	mov    $0x3,%edx
   0x5555555546bd <main+14>:	mov    $0x2,%esi
   0x5555555546c2 <main+19>:	mov    $0x1,%edi
   0x5555555546c7 <main+24>:	callq  0x55555555466a <test_function>

On this breakpoint, the stack frame for the test_function is created. The bottom of the new stack frame is at the current value of RSP, 0x7fffffffe650. The next breakpoint is right after the procedure prologue for test_function, so continuing will build the stack frame.

(gdb) c
Continuing.

Breakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:1
1	void test_function(int a, int b, int c, int d){

(gdb) i r rsp rbp rip
rsp            0x7fffffffe610	0x7fffffffe610
rbp            0x7fffffffe640	0x7fffffffe640
rip            0x55555555467e	0x55555555467e <test_function+20>

```
(gdb) disass test_function
Dump of assembler code for function test_function:
   0x000055555555466a <+0>:	push   rbp
   0x000055555555466b <+1>:	mov    rbp,rsp
   0x000055555555466e <+4>:	sub    rsp,0x30
   0x0000555555554672 <+8>:	mov    DWORD PTR [rbp-0x24],edi
   0x0000555555554675 <+11>:	mov    DWORD PTR [rbp-0x28],esi
   0x0000555555554678 <+14>:	mov    DWORD PTR [rbp-0x2c],edx
   0x000055555555467b <+17>:	mov    DWORD PTR [rbp-0x30],ecx
=> 0x000055555555467e <+20>:	mov    rax,QWORD PTR fs:0x28
   0x0000555555554687 <+29>:	mov    QWORD PTR [rbp-0x8],rax
   0x000055555555468b <+33>:	xor    eax,eax
   0x000055555555468d <+35>:	mov    DWORD PTR [rbp-0x18],0x7a69
   0x0000555555554694 <+42>:	mov    BYTE PTR [rbp-0x12],0x41
   0x0000555555554698 <+46>:	nop
   0x0000555555554699 <+47>:	mov    rax,QWORD PTR [rbp-0x8]
   0x000055555555469d <+51>:	xor    rax,QWORD PTR fs:0x28
   0x00005555555546a6 <+60>:	je     0x5555555546ad <test_function+67>
   0x00005555555546a8 <+62>:	call   0x555555554540 <__stack_chk_fail@plt>
   0x00005555555546ad <+67>:	leave  
   0x00005555555546ae <+68>:	ret    
End of assembler dump.
(gdb) print $rbp - 12
$1 = (void *) 0x7fffffffe634
(gdb) print $rbp - 40
$2 = (void *) 0x7fffffffe618
(gdb) x/16xw $rsp
0x7fffffffe610:	0x00000004	0x00000003	0x00000002	0x00000001
0x7fffffffe620:	0xf7de59a0	0x00007fff	0x00000000	0x00000000
0x7fffffffe630:	0x555546e0	0x00005555	0x55554560	0x00005555
0x7fffffffe640:	0xffffe650	0x00007fff	0x555546cc	0x00005555
```

Everything is completely backwards from what I expected from the book, and I don't understand anything. Maybe it's a versioning problem? The stack should be growing top down, and the 4,3,2,1 variables should be at the bottom, not at the top.

Oh, look:

"The various segments of memory are arranged in the order they were presented, from the lower memory addresses to the higher memory addresses. Since most people are familiar with seeing numbered lists that count downward, the smaller memory addresses are shown at the top. Some texts have this reversed, which can be very confusing; so for this book, smaller memory addresses Low addresses are always shown at the top. Most Text (code) segment debuggers also display memory in Data segment this style, with the smaller memory addresses at the top and the higher bss segment ones at the bottom."

Something isn't 100% right here. That's because I'm using x64 architecture, and the book assumes x86, I think. I'll follow along the best I can, but I won't worry too much about gdb sections.

### 0x271 - Memory Segments in C

In C, as in other compiled languages, the compiled code goes into the text segment, while the variables reside in the remaining segments.

Exactly which memory segment a variable will be stored in depends on how the variable is defined.

Variables that are defined outside of any functions are considered to be global. The static keyword can also be prepended to any variable declaration to make the variable static. If static or global variables are initialized with data, they are stored in the data memory segment; otherwise, these variables are put in the bss memory segment.

Memory on the heap memory segment must first be allocated using a memory allocation function called malloc() . Usually, pointers are used to reference memory on the heap.

Finally, the remaining function variables are stored in the stack memory segment. Since the stack can contain many different stack frames, stack variables can maintain uniqueness within different functional contexts.

### 0x272 - Using the heap

Using the other memory segments is simply a matter of how you declare variables. However, using the heap requires a bit more effort. Allocating memory on the heap is done using the malloc() function. This function accepts a size as its only argument and reserves that much space in the heap segment, returning the address to the start of this memory as a void pointer. If the malloc() function can’t allocate memory for some reason, it will simply return a NULL pointer with a value of 0.

Since malloc() doesn’t know what type of memory it’s allocating, it returns a void pointer to the newly allocated heap memory, which must be typecast into the appropriate type.

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]){
  char *char_ptr;  // a char pointer
  int *int_ptr;  // a int pointer
  int mem_size;

  if (argc < 2){
    mem_size = 50;
  }
  else{
    mem_size = atoi(argv[1]);
  }

  printf("\t[+] allocating %d bytes of memory on the heap for char_ptr\n", mem_size);

  char_ptr = (char *) malloc(mem_size);  // allocating memory

  // Error checking
  if (char_ptr == NULL){
    fprintf(stderr, "Error, could not allocate heap memory\n");
    exit(-1);
  }

  strcpy(char_ptr, "This memory is located on the heap.");
  printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);

  printf("\t[+] allocating 12 bytes of memory on the heap for int_ptr\n");
  int_ptr = (int *) malloc(12);  // allocating memory

  // Error checking
  if (int_ptr == NULL){
    fprintf(stderr, "Error, could not allocate heap memory\n");
    exit(-1);
  }

  *int_ptr= 31337;
  printf("int_ptr (%p) --> '%d'\n", int_ptr, *int_ptr);

  printf("\t[-] freeing char_ptr's heap memory\n");
  free(char_ptr);  // freeing heap memory

  printf("\t[+] allocating another 15 bytes for char_ptr\n");
  char_ptr = (char *) malloc(15);  // allocating memory

  // Error checking
  if (char_ptr == NULL){
    fprintf(stderr, "Error, could not allocate heap memory\n");
    exit(-1);
  }

  strcpy(char_ptr, "new memory");
  printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);

  printf("\t[-] freeing int_ptr's heap memory\n");
  free(int_ptr);  // freeing heap memory
  printf("\t[-] freeing char_ptr's heap memory\n");
  free(char_ptr);  // freeing heap memory
}
```

\# ./heap_example
	[+] allocating 50 bytes of memory on the heap for char_ptr
char_ptr (0x563f862c3670) --> 'This memory is located on the heap.'
	[+] allocating 12 bytes of memory on the heap for int_ptr
int_ptr (0x563f862c36b0) --> '31337'
	[-] freeing char_ptr's heap memory
	[+] allocating another 15 bytes for char_ptr
char_ptr (0x563f862c36d0) --> 'new memory'
	[-] freeing int_ptr's heap memory
	[-] freeing char_ptr's heap memory

In the preceding output, notice that each block of memory has an incrementally higher memory address: 3670, then 36b0, and finally 36d0. Even though the first 50 bytes were deallocated, when 15 more bytes are requested, they are put after the 12 bytes allocated for the int_ptr. (the null byte at the end of the string makes for the 16th).

For a more in detail version of how malloc and free work, dive deep into this ["build your own malloc tutorial"](https://arjunsreedharan.org/post/148675821737/memory-allocators-101-write-a-simple-memory).

## 0x280 Building on Basics

Once you understand the basic concepts of C programming, the rest is pretty easy. The bulk of it comes from using other functions.

### 0x281 - File Access

There are two primary ways to access files in C: file descriptors and filestreams. *Descriptors* use a set of low-level I/O functions, and *filestreams* are a higher-level form of buffered I/O that is built on the lower-level functions.

Four common functions that use file descriptors are open(), close(), read(), and write(). The function open() returns a file descriptor, which is just an integer value, but it's a unique one among open files. That integer is passed as an argument to other functions like a pointer to the opened file. close() is to open() what free() is to malloc(). The read() and write() functions' arguments are the file descriptor, a pointer to the data to read or write, and the number of bytes to read or write.

We can see all this in simplenote.c:


```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>

void usage(char *prog_name, char *filename){
  printf("Usage: %s <data to add to %s>\n", prog_name, filename);
  exit(0);
}

void fatal(char *);  // A function for fatal errors
void *ec_malloc(unsigned int);  // An error-checked malloc wrapper

int main(int argc, char *argv[]){
  int fd; // file descriptor
  char *buffer, *datafile;

  buffer = (char *) ec_malloc(100);
  datafile = (char *) ec_malloc(20);
  strcpy(datafile, "/tmp/notes");

  if(argc < 2){
    usage(argv[0], datafile);
  }

  strcpy(buffer, argv[1]);  // copy into buffer
  printf("[DEBUG] buffer @ %p: \'%s\'\n", buffer, buffer);
  printf("[DEBUG] datafile @ %p: \'%s\'\n", datafile, datafile);

  strncat(buffer, "\n", 1);  // Add a new line on the end

  // Opening file
  fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
  if(fd == -1){
    fatal("In main(), while opening file");
  }

  printf("[DEBUG] File descriptor is %d\n", fd);

  // Writing data
  if (write(fd, buffer, strlen(buffer)) == -1){
    fatal("In main(), while writing buffer to file");
  }

  // Closing file
  if (close(fd) == -1){
    fatal("In main(), while closing the file");
  }

  printf("Note has been saved.\n");
  free(buffer);
  free(datafile);
}

void fatal(char *message){
  char error_message[100];
  strcpy(error_message, "[!!] Fatal error");
  strncat(error_message, message, 83);
  perror(error_message);
  exit(-1);
}

void *ec_malloc(unsigned int size){
  void *ptr;
  ptr = malloc(size);
  if (ptr == NULL){
    fatal("In ec_malloc(), on memory allocation");
  };
  return ptr;
}
```

\# ./simplenote
Usage: ./simplenote <data to add to /tmp/notes>
root@04c6c004cdf8:/app# ./simplenote "this is a test note"
[DEBUG] buffer @ 0x5615afe90260: 'this is a test note'
[DEBUG] datafile @ 0x5615afe902d0: '/tmp/notes'
[DEBUG] File descriptor is 3
Note has been saved.
\# cat /tmp/notes
this is a test note
\# ./simplenote "great, it works!"
[DEBUG] buffer @ 0x557170c95260: 'great, it works!'
[DEBUG] datafile @ 0x557170c952d0: '/tmp/notes'
[DEBUG] File descriptor is 3
Note has been saved.
\# cat /tmp/notes
this is a test note
great, it works!

Besides the strange-looking flags used in open(), most of the code is readable. strlen() accepts a string and returns its length, and it's used in combination with write() to know how many bytes are needed.

The files fcntl.h and sys/stat.h had to be included, since those files define the flags used in open().

- O_RDONLY: Open file for read-only access
- O_WRONLY: Open file for write-only access
- O_RDWR: Open file for both read AND write access
- O_APPEND: Write data at the end of the file
- O_TRUNC: If the file already exists, truncate the file to 0 length
- O_CREAT: Create the file if it doesn't exist.

These flags can be combined using the bitwise OR operator. In fact, they have values that correspond to single bits; this way, flags can be combined using OR logic without destroying any information:

O_RDONLY			                : 0	     00000000 00000000 00000000 00000000
O_WRONLY			                : 1	     00000000 00000000 00000000 00000001
O_RDWR			                  : 2	     00000000 00000000 00000000 00000010

O_APPEND			                : 1024	 00000000 00000000 00000100 00000000
O_TRUNC			                  : 512	   00000000 00000000 00000010 00000000
O_CREAT			                  : 64	   00000000 00000000 00000000 01000000

O_WRONLY|O_APPEND|O_CREAT			: 1089	 00000000 00000000 00000100 01000001

This technique only works when all the bits are unique, though.

### 0x282 File Permissions

If the O_CREAT flag is used, an additional argument is needed to define the file permissions of the newly created file. This argument uses bit flags defined in sys/stat.h, which can also be combined using bitwise OR logic.

- S_IRUSR: Give the file read permission for the user (owner)
- S_IWUSR: Give the file write permission for the user (owner)
- S_IXUSR: Give the file execute permissions for the user (owner)
- S_IRGRP: Give the file read permission for the group
- S_IWGRP: Give the file write permission for the group
- S_IXGRP: Give the file execute permission for the group
- S_IROTH: Give the file read permission for other (anyone)
- S_IWOTH: Give the file write permission for other (anyone)
- S_IXOTH: Give the file execute permission for other (anyone)

Every file has an owner and a group. These values can be displayed using ls -l and are show in the following manner:

$ ls -l /etc/passwd simplenote*

-rw-r--r-- 1 root   root   1424 2007-09-06 09:45 /etc/passwd
-rwxr-xr-x 1 reader reader 8457 2007-09-07 02:51 simplenote
-rw------- 1 reader reader 1872 2007-09-07 02:51

For the /etc/passwd file, the owner is root and the group is also root. For the other two simplenote files, the owner is the reader and the group is users.

Execute, read and write permissions can be turned on and off for three different fields: user, group and other. These fields are displayed in the front of the ls -l output. First, user xrw-, x for execute, r for read, w for write and - for off. The next three characters display group permissions, again xrw-, and finally for other.

In the output above, the simplenote program has all three user permissions turned on. Each permission corresponds to a bit flag: read is 4 (binary 100), write is 2 (binary 10) and execute is 1 (binary 1), so a bitwise OR operation achieves the same result as adding these numbers together. These values can be added together to define permissions for user, group and other using the chmod command.

$ chmod 731 simplenote.c

$ ls -l simplenote.c
-rwx-wx--x 1 reader reader 1826 2007-09-07 02:51 simplenote.c

$ chmod ugo-wx simplenote.c

$ ls -l simplenote.c
-r-------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c

$ chmod u+w simplenote.c

$ ls -l simplenote.c
-rw------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c

chmod 731 gives read write and execute permission to the user, since the first number is 7 (4 + 2 + 1), write and execute permission to the group, since the second number is 3 (2 + 1), and only execution to other, since the last number is 1.

In the next chmod command, the argument `ugo-wx` means *substract wirte and execute permissions from user, group and other*. The structure is owner types, then + or -, then permission codes. Like the last one, `u+w`, which adds write permission to the user.

In the simplenote program, the open() function uses S_IRUSR|S_IWUSR for its additional permission argument, which means the /tmp/notes file should only have user read and write permissions when it is created:

\# ls -l /tmp/notes
-rw------- 1 root root 37 Feb  8 15:40 /tmp/notes

#### 0x283 User IDs

Every user has a unique user ID number, which can be displayed using the `id` command:

```
$ id root
uid=0(root) gid=0(wheel) groups=0(wheel),1(daemon),2(kmem),3(sys),4(tty),5(operator),8(procview),9(procmod),12(everyone),20(staff),29(certusers),61(localaccounts),80(admin),701(com.apple.sharepoint.group.1),33(_appstore),98(_lpadmin),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh),400(com.apple.access_remote_ae)
```

Root has id 0, and has full access to the system. The `su` command can be used to switch user, and if this command is run as root, there is no need for a password. The sudo command allows a single command to be run as the root user.

The command `chsh` allows any user to change his or her own login shell. This program needs to be able to make changes to the /etc/passwd file, but only on the line that pertains to the current user's account. The solution in Unix is the command `setuid` permission. This is an additional file permission bit that can be set using chmod. When a prorgam with this flag is executed, it runs as the user ID of the file's owner:

```
$ which chsh
/usr/bin/chsh

$ ls -l /usr/bin/chsh /etc/passwd
-rw-r--r--  1 root  wheel   6946 Nov  9 10:54 /etc/passwd
-rwxr-xr-x  1 root  wheel  46240 Jan 23 14:59 /usr/bin/chsh
```

[The chsh program has the setuid flag set](https://security.stackexchange.com/questions/102172/chsh-command-security-with-set-uid). However, instead of the -s flag, I see the execute permissions. So something is going on behind the scenes.

Since /etc/passwd is owned by root (only root has w permission), and has the setuid permission set, the program will run as the root user when any user runs this program. The program login in chsh is designed to only allow writing to the line in /etc/passwd that corresponds to the user running the program, even though the program is effectively running as root. This means that a running progrm has both a real user ID and an effective user ID:

```
#include <stdio.h>

int main(){
  printf("real uid: %d\n", getuid());
  printf("effective uid: %d\n", geteuid());
}
```

$ ./uid_demo
real uid: 501
effective uid: 501

$ ls -l uid_demo
-rwxr-xr-x  1 alvaroduran  staff  12652 Feb  9 13:38 uid_demo

interestingly enough, running uid_demo from docker returns id=0, because inside docker you're always logged in as root. However, from the host, uid_demo can be compiled and used as a normal user, which will show you execute and read permissions for the user.

> [Running containers (and applications) with Docker implies running the Docker daemon. This daemon requires root privileges](https://docs.docker.com/engine/security/security/).

This same technique can be used in a multiuser note-taking program. The next program will be a modification of the simplenote program; it will also record the user ID of each note's original author. In addition, a new syntax for include will be introduced.

First, let's separate ec_malloc and fatal functions into an include file, called `hacking.h`:

```code
// A function to display an error message and then exit
void fatal(char *message){
  char error_message[100];

  strcpy(error_message, "[!!] Fatal Error");
  strncat(error_message, message, 83);
  perror(error_message);
  exit(-1);
}

// An error-checked malloc wrapper function
void *ec_malloc(unsigned int size){
  void *ptr;
  ptr = malloc(size);

  if(ptr == NULL){
    fatal("In ec_malloc(), on memory allocation");
  }
  return ptr;
}
```

In this new program, the function can just be included. In C, when the filename for a #include is surrounded by < and >, the compiler looks for this file in standard include paths, such as /usr/include. If the filename is surrounded by quotes, the compiler looks in the current directory. Therefore, we can include hacking.h in our notetaker.c file as follows:

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include "hacking.h"

void usage(char *prog_name, char *filename){
  printf("Usage: %s <data to add to %s\n", prog_name, filename);
  exit(0);
}

void fatal(char *);
void *ec_malloc(unsigned int);

int main(int argc, char *argv[]){
  int userid, fd;
  char *buffer, *datafile;

  buffer = (char *) ec_malloc(100);
  datafile = (char *) ec_malloc(20);

  strcpy(datafile, "/var/notes");

  if (argc < 2){
    usage(argv[0], datafile);
  }

  strcpy(buffer, argv[1]); // Copy into buffer

  printf("[DEBUG] buffer @ %p: \'%s\'\n", buffer, buffer);
  printf("[DEBUG] datafile @ %p: \'%s\'\n", datafile, datafile);

  // Opening the file
  fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);

  if(fd == -1){
    fatal("In main(), while opening file");
  }
  printf("[DEBUG] file descriptor is %d\n", fd);

  userid = getuid();

  // Write user ID before data
  if(write(fd, &userid, 4) == -1){
    fatal("In main(), while writing userid to file");
  }
  write(fd, "\n", 1);

  // Write note
  if(write(fd, buffer, strlen(buffer)) == -1){
    fatal("In main(), while writing buffer to file");
  }
  write(fd, "\n", 1);

  // Closing file
  if(close(fd) == -1){
    fatal("In main, while closing file");
  }

  printf("Note has been saved\n");
  free(buffer);
  free(datafile);
}
```


$ ls -l notetaker
-rwxr-xr-x  1 ohduran  staff  13188 Feb  9 14:03 notetaker

$ sudo chown root:staff ./notetaker

$ sudo chmod u+s ./notetaker

$ ls -l ./notetaker
-rwsr-xr-x  1 root  staff  13188 Feb  9 14:03 ./notetaker

$ ./notetaker "this is a test of multiuser notes"
[DEBUG] buffer @ 0x7fcebd401750: 'this is a test of multiuser notes'
[DEBUG] datafile @ 0x7fcebd4017c0: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved

$ ls -l /var/notes
-rw-------  1 root  wheel  39 Feb  9 14:05 /var/notes

$ cat /var/notes
cat: /var/notes: Permission denied

HA! Permission denied! That's because only root has read and write permissions.

$ sudo cat /var/notes
?
this is a test of multiuser notes

$ sudo hexdump -C /var/notes
00000000  f5 01 00 00 0a 74 68 69  73 20 69 73 20 61 20 74  |.....this is a t|
00000010  65 73 74 20 6f 66 20 6d  75 6c 74 69 75 73 65 72  |est of multiuser|
00000020  20 6e 6f 74 65 73 0a                              | notes.|
00000027

See the little endian first number? What could that be?

$ pcalc 0x01f5
	501             	0x1f5             	0y111110101

My user ID!! The /var/notes file contains the user ID of reader (501) and the note. Because of little-endian architecture, the 4 bytes of the integer 999 appear reversed in hexadecimal.

In order for a normal user to be able to read the note data, a corresponding setuid root program is needed. The notesearch.c program will read the note data and only display the notes written by that user ID.

```
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include "hacking.h"

# define FILENAME "/var/notes"

int print_notes(int, int, char *);
int find_user_note(int, int);
int search_note(char *, char *);
void fatal(char *);

int main(int argc, char *argv[]){
  int userid, printing=1, fd;
  char searchstring[100];

  if (argc > 1){
    strcpy(searchstring, argv[1]);
  }
  else{
    searchstring[0] = 0;
  }

  userid = getuid();
  fd = open(FILENAME, O_RDONLY);

  if(fd == -1){
    fatal("In main(), while opening file for reading");
  }

  while(printing){
    printing = print_notes(fd, userid, searchstring);
  }
  printf("-----[ end of note data ]-----\n");
  close(fd);
}


int print_notes(int fd, int uid, char *searchstring){
  int note_length;
  char byte = 0, note_buffer[100];

  note_length = find_user_note(fd, uid);

  if(note_length == -1 ){
    return 0; // stop printing!
  }

  read(fd, note_buffer, note_length);
  note_buffer[note_length] = 0;

  if(search_note(note_buffer, searchstring)){
    printf(note_buffer);
  }
  return 1;  // keep on printing
}

int find_user_note(int fd, int user_uid){
  int note_uid = -1;
  unsigned char byte;
  int length;

  while(note_uid != user_uid){
    if (read(fd, &note_uid, 4) != 4){ // read the unit data
      return -1; // if 4 bytes aren't read, return end of file code
    }

    if(read(fd, &byte, 1) != 1){
      return -1;
    }

    byte = length = 0;
    while(byte != '\n'){
      if (read(fd, &byte, 1) != 1){
        return -1;
      }
      length++;
    }
  }

  lseek(fd, length * -1, SEEK_CUR); // rewind file reading by length bytes
  printf("[DEBUG] found a %d byte note for user id %d\n", length, note_uid);
  return length;
}

int search_note(char *note, char *keyword){
  int i, keyword_length, match=0;

  keyword_length = strlen(keyword);

  if(keyword_length == 0){
    return 1; // always match
  }

  for(i=0; i<keyword_length; i++){
    if(note[i] == keyword[match]){
      match++; // get ready to check the next byte
    }
    else{
      if(note[i] == keyword[0]){
        match = 1; // if that byte mathches the first keyword byte,
        // start at 1
      }
      else{
        match = 0;
      }
    }
    if(match == keyword_length){
      return 1;
    }

  }
  return 0;
}
```

Even though both the notetaker and the notesearch programs are suid root and have full read and write access to the /var/notes datafile, the program logic in the notesearch program prevents the current user from viewing other users' notes. This is very similar to how the /etc/passwd file stores user information for all users, yet programs like chsh and passwd allow any user to change his own shell or password.

#### 0x284 Structs

Sometimes there are multiple variables that should be grouped together and treated like one. In C, *structs* are variables that contain many other variables.

For instance, when dealing with many time functions, these functions often use a time struct called `tm`, which is defined in /usr/include/time.h, and is defined as follows:

```code
struct tm {
  int     tm_sec; // seconds
  int     tm_min; // minutes
  int     tm_hour; // hours
  int     tm_mday; // day of the month
  int     tm_mon; // month
  int     tm_year; // year
  int     tm_wday; // day of the week
  int     tm_yday; // day in the year
  int     tm_isdst; // daylight saving time
}
```

After this struct is defined, struct tm becomes a usable variable type, which can be used to declare variables and pointers with the data type of the `tm` struct. The time_example.c file demonstrates it:

```
#include <stdio.h>
#include <time.h>

int main(){
  long int seconds_since_epoch;
  struct tm current_time, *time_ptr;
  int hour, minute, second, day, month, year;

  seconds_since_epoch = time(0); // Pass time a null pointer as argument.
  printf("time() - seconds since epoch: %d\n", seconds_since_epoch);

  time_ptr = &current_time;

  localtime_r(&seconds_since_epoch, time_ptr);

  // Three different ways to access struct elements
  hour = current_time.tm_hour; // Direct
  minute = time_ptr->tm_min; // Via pointer
  second = *((int *) time_ptr); // Hacky pointer access

  printf("Current time is %02d:%02d:%02d\n", hour, minute, second);
}
```

$ ./a.out
time() - seconds since epoch: 1581362790
Current time is 20:26:30

When time.h is included, the tm struct is defined, which is later used to declare the current_time and time_ptr variables. `time()` will return the number of seconds since Jan 1, 1970, also called *epoch*. The `localtime_r()` function expects two pointers as arguments: one to the number of seconds since epoch and the other to a `tm` struct. The pointer time_ptr is already set to be the address of current_time, an empty tm struct, and the address-of, &, is used to provide a pointer to seconds_since_epoch for the other argument to localtime_r. That will fill the element of current_time, which is pointed by time_ptr.

Elements of structs can be accessed in three different ways:

1. If a struct variable is used, then we can access it via period: the struct is `current_time` and the variable inside is called `tm_hour`, so the value of the variable tm_hour inside current_time is `current_time.tm_hour`.
2. Pointers to structs are often used, since it's much more efficient to pass addresses than passing entire data structures to functions. In fact, it's so common, C has a built-in method to access struct elements from a struct pointer, *without* needing to dereference that pointer. If `time_ptr` is the struct pointer, and the variable is `tm_min`, then the value of the variable tm_min of whatever struct the pointer `time_ptr` is pointing at is `time_ptr->tm_min`.
3. What about the third option? That is recasting time_ptr as an int pointer, and then whatever that int pointer points at is the value of seconds? That sounds like, in C, structs are simply saved in memory one next to the other, and we are simply assuming that the variable seconds is an int variable that sits in first place within the data structure. Which is what's happening:

> Remember that in the end, it’s all just memory. Since tm_sec is defined at the beginning of the tm struct, that integer value is also found at the beginning. In the line second = \*((int \*) time_ptr), the variable time_ptr is typecast from a tm struct pointer to an integer pointer. Then this typecast pointer is dereferenced, returning the data at the pointer’s address. Since the address to the tm struct also points to the first element of this struct, this will retrieve the integer value for tm_sec in the struct.

We can confirm that using the program time_example2.c
```
#include <stdio.h>
#include <time.h>

void dump_time_struct_bytes(struct tm *time_ptr, int size){
  int i;
  unsigned char *raw_ptr;
  printf("bytes of struct located at 0x%08x\n", time_ptr);
  raw_ptr = (unsigned char *) time_ptr;

  for(i=0; i<size; i++){
    printf("%02x ", raw_ptr[i]);
    // Print a new line every 16 bytes
    if(i % 16 == 15){
      printf("\n");
    }
  }
  printf("\n");
}


int main(){
  long int seconds_since_epoch;
  struct tm current_time, *time_ptr;

  int hour, minute, second, i, *int_ptr;


  seconds_since_epoch = time(0);
  printf("time() - seconds since epoch: %ld\n", seconds_since_epoch);

  time_ptr = &current_time;
  localtime_r(&seconds_since_epoch, time_ptr);

  hour = current_time.tm_hour;
  minute = time_ptr->tm_min;
  second = *((int *) time_ptr);

  printf("Current time is %02d:%02d:%02d\n", hour, minute, second);

  dump_time_struct_bytes(time_ptr, sizeof(struct tm));

  minute = hour = 0; // Clear out
  int_ptr = (int *) time_ptr;

  for(i=0; i<3; i++){
    printf("int_ptr @ 0x%08x : %d\n", int_ptr, *int_ptr);
    int_ptr++; // having been casted as an integer, this will move the pointer in 4.
  }
}
```

$ ./a.out
time() - seconds since epoch: 1581444354
Current time is 19:05:54
bytes of struct located at 0xe550aa88
36 00 00 00 05 00 00 00 13 00 00 00 0b 00 00 00
01 00 00 00 78 00 00 00 02 00 00 00 29 00 00 00
00 00 00 00 00 00 00 00 10 0e 00 00 00 00 00 00
5f 52 80 98 ad 7f 00 00
int_ptr @ 0xe550aa88 : 54
int_ptr @ 0xe550aa8c : 5
int_ptr @ 0xe550aa90 : 19

While struct can be accessed this way, there is no easy way to tell what is what; thus, using proper methods to access struct elements is much easier.

#### 0x285 Function pointers

A *pointer* is simply a memory address, which is given a special data type. Usually, pointers are used for variables, but they can also be used for functions.
