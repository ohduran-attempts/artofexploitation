# Art of Exploitation

- Hackers get their edge from knowing how all the pieces interact within the bigger picture.

- Thinking of C-source as a program is a common misconception that is exploited by hackers every day. As long as the compiled program works, the average programmer is only concerned with source code. But a hacker realizes that the compiled program is what actually gets executed out in the real world.

- Most hacker exploits are a lot like magic tricks—they seem amazing and magical, unless you know about sleight of hand and misdirection.

## Programming

### firstprog.c & firstprog.txt

The hexadecimal numbers— 100000f40— are memory addresses. Like a row of houses on a local street, memory can be thought of as a row of bytes, each with its own memory address.

The hexadecimal bytes in the middle are the machine language instructions for the processor. The machine code is displayed as bytes and each instruction is put on its own line, like splitting a paragraph into sentences.

The instructions on the far right are in assembly language; a collection of mnemonics for the corresponding machine language instructions. Assembly language instructions have a direct one-to-one relationship with their corresponding machine language instruction; each processor has a different form of assembly language. While you can theoretically create your own x86 assembly language syntax, most people stick with one of the two main types: AT&T syntax and Intel syntax. It’s easy to recognize AT&T syntax by the cacophony of % and $ symbols prefixing everything.

### GDB
Inside Docker: ```docker run --rm -v $(pwd):/app ubuntu:latest bash```

```gdb -q ./a.out```

#### General purpose registers:

- rax: Accumulator
- rbx: Base
- rcx: Counter
- rdx: Data

Temporary variables for the CPU

#### Pointers and indexes

- rsi: Source Index
- rdi: Destination Index
- rbi: Base Pointer
- rsi: Stack Pointer

Pointers store memory addresses; Indexes point to source and destination where data needs to be read from or written to.

### Instruction Pointer

- rip: Instruction Pointer

Like a child pointing his finger at each word as he reads, the processor reads each instruction using the RIP register as finger.

At first, it points at 0x5648307eb63e. Check out firstprog-Intel-ubuntu: the first memory address is 63a!

Now, what is 63b and 63e doing:

63b:	48 89 e5             	mov    rbp,rsp
63e:	48 83 ec 10          	sub    rsp,0x10

The assembly instructions in Intel syntax generally follow this style: operation <destination>, <source>. Mov will move a value from the source to destination, sub will subtract, inc will increment, etc.

- gdb break main ... run ... info registers rip

First, the breakpoint is set at the start of main(), and the program is run. Since the breakpoint has been set at the start of main, the program hits the breakpoint and pauses before actually executing any instructions in main.

notice that ```info register rip``` points to an instruction in the main() function's disassembly (the fourth, to be precise). The instruction before this are collectively known as the *function prologue* and aer generated to set up memory for the rest of the main function local variables. In fact, we declare. variables in C in order to aid the construction of this prologue.

The debugger knows this, and skips over this part.

- Examine memory using ```x```

The default size of a single unit is a four byte unit called a *word*. This is confusing because sometimes it also refers to a 2 byte value, and thus a DWORD, or double word refers to a 4-byte value. We'll use word and DWORD interchangeably.

b - single byte
h - halfword, two bytes
w - word, four bytes
g - giant, eight bytes

You can try ```x/8xb $rip```. This is what you may get:

x/8xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00	0xeb

x/8xh $rip

0x563dfc6f1642 <main+8>:	0x45c7	0x00fc	0x0000	0xeb00	0x4810	0x3d8d	0x00a2	0x0000

x/8xw $rip

0x563dfc6f1642 <main+8>:	0x00fc45c7	0xeb000000	0x3d8d4810	0x000000a2
0x563dfc6f1652 <main+24>:	0xfffeb9e8	0xfc4583ff	0xfc7d8301	0xb8ea7e09


Now, you may have noticed that those commands that use bigger units display more data. However, x/8xb showed the first two bytes to be 0xc7 and 0x45, __but__ x/8xh showed that memory address to be 0x45c7, and x/8xw also shows 0x00fc45c7, which keeps reversing the two memory addresses showed in x/8xh.

In the x86 processor, values are storesd in *little-endian* byte order, which means that the least significant byte is stored first. GDB is simply smart enough to know how values are stored, so when a word or halfword is examined, the bytes must be reversed.

Revisiting these values displayed both as hexadecimal and unsigned decimals might help clear up any confusion.

x/4xb $rip

0x563dfc6f1642 <main+8>:	0xc7	0x45	0xfc	0x00

x/4ub $rip

0x563dfc6f1642 <main+8>:	199	69	252	0

x/1uw $rip

0x563dfc6f1642 <main+8>:	16532935

Notice this: 199 * (256^3) + 69 * (256^2) + 252 * (256^1) + 0 = 3343252480 WRONG!

But: 0 * (256^3) + 252 * (256^2) + 69 * (256^1) + 199 = 16532935 RIGHT!




